import { allTokens, ChevSparqlLexer } from '../../lexer';
import { Builder } from '../buildExample';
import {
  aggregate,
  aggregateAvg,
  aggregateCount,
  aggregateGroup_concat,
  aggregateMax,
  aggregateMin,
  aggregateSample,
  aggregateSum,
  builtInAbs,
  builtInBnode,
  builtInBound,
  builtInCall,
  builtInCeil,
  builtInCoalesce,
  builtInConcat,
  builtInContains,
  builtInDatatype,
  builtInDay,
  builtInEncode_for_uri,
  builtInFloor,
  builtInHours,
  builtInIf,
  builtInIri,
  builtInIsblank,
  builtInIsiri,
  builtInIsliteral,
  builtInIsnumeric,
  builtInIsuri,
  builtInLang,
  builtInLangmatches,
  builtInLcase,
  builtInMd5,
  builtInMinutes,
  builtInMonth,
  builtInNow,
  builtInRand,
  builtInRound,
  builtInSameterm,
  builtInSeconds,
  builtInSha1,
  builtInSha256,
  builtInSha384,
  builtInSha512,
  builtInStr,
  builtInStrafter,
  builtInStrbefore,
  builtInStrdt,
  builtInStrends,
  builtInStrlang,
  builtInStrlen,
  builtInStrstarts,
  builtInStruuid,
  builtInTimezone,
  builtInTz,
  builtInUcase,
  builtInUri,
  builtInUuid,
  builtInYear,
  existsFunc,
  notExistsFunc,
  regexExpression,
  strReplaceExpression,
  substringExpression,
} from './builtIn';
import { datasetClause, defaultGraphClause, namedGraphClause, sourceSelector } from './dataSetClause';
import {
  additiveExpression,
  argList,
  brackettedExpression,
  conditionalAndExpression,
  conditionalOrExpression,
  expression,
  expressionList,
  iriOrFunction,
  multiplicativeExpression,
  numericExpression,
  primaryExpression,
  relationalExpression,
  unaryExpression,
  valueLogical,
} from './expression';
import {
  baseDecl,
  blankNodePropertyList,
  collection,
  graphNode,
  graphTerm,
  object,
  objectList,
  prefixDecl,
  prologue,
  propertyList,
  propertyListNotEmpty,
  triplesNode,
  triplesSameSubject,
  triplesTemplate,
  var_,
  varOrIri,
  varOrTerm,
  verb,
} from './general';
import {
  blankNode,
  booleanLiteral,
  iri,
  numericLiteral,
  numericLiteralNegative,
  numericLiteralPositive,
  numericLiteralUnsigned,
  prefixedName,
  rdfLiteral,
  string,
} from './literals';
import {
  path,
  pathAlternative,
  pathElt,
  pathEltOrInverse,
  pathMod,
  pathNegatedPropertySet,
  pathOneInPropertySet,
  pathPrimary,
  pathSequence,
} from './propertyPaths';
import {
  askQuery,
  constructQuery,
  constructTemplate,
  constructTriples,
  describeQuery,
  query,
  queryUnit,
  selectClause,
  selectQuery,
  subSelect,
  valuesClause,

} from './queryUnit';
import {
  groupClause,
  groupCondition,
  havingClause,
  havingCondition,
  limitClause,
  limitOffsetClauses,
  offsetClause,
  orderClause,
  orderCondition,
  solutionModifier,
} from './solutionModifier';
import {
  blankNodePropertyListPath,
  collectionPath,
  graphNodePath,
  objectListPath,
  objectPath,
  propertyListPath,
  propertyListPathNotEmpty,
  triplesBlock,
  triplesNodePath,
  triplesSameSubjectPath,
  verbPath,
  verbSimple,
} from './tripleBlock';
import {
  add,
  clear,
  copy,
  create,
  deleteClause,
  deleteData,
  deleteWhere,
  drop,
  graphOrDefault,
  graphRef,
  graphRefAll,
  insertClause,
  insertData,
  load,
  modify,
  move,
  quadData,
  quadPattern,
  quads,
  quadsNotTriples,
  update,
  update1,
  updateUnit,
  usingClause,
} from './updateUnit';
import {
  bind,
  constraint,
  dataBlock,
  dataBlockValue,
  filter,
  functionCall,
  graphGraphPattern,
  graphPatternNotTriples,
  groupGraphPattern,
  groupGraphPatternSub,
  groupOrUnionGraphPattern,
  inlineData,
  inlineDataFull,
  inlineDataOneVar,
  minusGraphPattern,
  optionalGraphPattern,
  serviceGraphPattern,
  whereClause,
} from './whereClause';

// [97]: unused

export const sparql12Builder = Builder.createBuilder()
  .addRule(queryUnit)
  .addRule(query)
  .addRule(updateUnit)
  .addRule(prologue)
  .addRule(baseDecl)
  .addRule(prefixDecl)
  .addRule(selectQuery)
  .addRule(subSelect)
  .addRule(selectClause)
  .addRule(constructQuery)
  .addRule(describeQuery)
  .addRule(askQuery)
  .addRule(datasetClause)
  .addRule(defaultGraphClause)
  .addRule(namedGraphClause)
  .addRule(sourceSelector)
  .addRule(whereClause)
  .addRule(solutionModifier)
  .addRule(groupClause)
  .addRule(groupCondition)
  .addRule(havingClause)
  .addRule(havingCondition)
  .addRule(orderClause)
  .addRule(orderCondition)
  .addRule(limitOffsetClauses)
  .addRule(limitClause)
  .addRule(offsetClause)
  .addRule(valuesClause)
  .addRule(update)
  .addRule(update1)
  .addRule(load)
  .addRule(clear)
  .addRule(drop)
  .addRule(create)
  .addRule(add)
  .addRule(move)
  .addRule(copy)
  .addRule(insertData)
  .addRule(deleteData)
  .addRule(deleteWhere)
  .addRule(modify)
  .addRule(deleteClause)
  .addRule(insertClause)
  .addRule(usingClause)
  .addRule(graphOrDefault)
  .addRule(graphRef)
  .addRule(graphRefAll)
  .addRule(quadPattern)
  .addRule(quadData)
  .addRule(quads)
  .addRule(quadsNotTriples)
  .addRule(triplesTemplate)
  .addRule(groupGraphPattern)
  .addRule(groupGraphPatternSub)
  .addRule(triplesBlock)
  .addRule(graphPatternNotTriples)
  .addRule(optionalGraphPattern)
  .addRule(graphGraphPattern)
  .addRule(serviceGraphPattern)
  .addRule(bind)
  .addRule(inlineData)
  .addRule(dataBlock)
  .addRule(inlineDataOneVar)
  .addRule(inlineDataFull)
  .addRule(dataBlockValue)
  .addRule(minusGraphPattern)
  .addRule(groupOrUnionGraphPattern)
  .addRule(filter)
  .addRule(constraint)
  .addRule(functionCall)
  .addRule(argList)
  .addRule(expressionList)
  .addRule(constructTemplate)
  .addRule(constructTriples)
  .addRule(triplesSameSubject)
  .addRule(propertyList)
  .addRule(propertyListNotEmpty)
  .addRule(verb)
  .addRule(objectList)
  .addRule(object)
  .addRule(triplesSameSubjectPath)
  .addRule(propertyListPath)
  .addRule(propertyListPathNotEmpty)
  .addRule(verbPath)
  .addRule(verbSimple)
  .addRule(objectListPath)
  .addRule(objectPath)
  .addRule(path)
  .addRule(pathAlternative)
  .addRule(pathSequence)
  .addRule(pathElt)
  .addRule(pathEltOrInverse)
  .addRule(pathMod)
  .addRule(pathPrimary)
  .addRule(pathNegatedPropertySet)
  .addRule(pathOneInPropertySet)
  .addRule(triplesNode)
  .addRule(blankNodePropertyList)
  .addRule(triplesNodePath)
  .addRule(blankNodePropertyListPath)
  .addRule(collection)
  .addRule(collectionPath)
  .addRule(graphNode)
  .addRule(graphNodePath)
  .addRule(varOrTerm)
  .addRule(varOrIri)
  .addRule(var_)
  .addRule(graphTerm)
  .addRule(expression)
  .addRule(conditionalOrExpression)
  .addRule(conditionalAndExpression)
  .addRule(valueLogical)
  .addRule(relationalExpression)
  .addRule(numericExpression)
  .addRule(additiveExpression)
  .addRule(multiplicativeExpression)
  .addRule(unaryExpression)
  .addRule(primaryExpression)
  .addRule(brackettedExpression)
  .addRule(builtInCall)
  .addRule(builtInStr)
  .addRule(builtInLang)
  .addRule(builtInLangmatches)
  .addRule(builtInDatatype)
  .addRule(builtInBound)
  .addRule(builtInIri)
  .addRule(builtInUri)
  .addRule(builtInBnode)
  .addRule(builtInRand)
  .addRule(builtInAbs)
  .addRule(builtInCeil)
  .addRule(builtInFloor)
  .addRule(builtInRound)
  .addRule(builtInConcat)
  .addRule(builtInStrlen)
  .addRule(builtInUcase)
  .addRule(builtInLcase)
  .addRule(builtInEncode_for_uri)
  .addRule(builtInContains)
  .addRule(builtInStrstarts)
  .addRule(builtInStrends)
  .addRule(builtInStrbefore)
  .addRule(builtInStrafter)
  .addRule(builtInYear)
  .addRule(builtInMonth)
  .addRule(builtInDay)
  .addRule(builtInHours)
  .addRule(builtInMinutes)
  .addRule(builtInSeconds)
  .addRule(builtInTimezone)
  .addRule(builtInTz)
  .addRule(builtInNow)
  .addRule(builtInUuid)
  .addRule(builtInStruuid)
  .addRule(builtInMd5)
  .addRule(builtInSha1)
  .addRule(builtInSha256)
  .addRule(builtInSha384)
  .addRule(builtInSha512)
  .addRule(builtInCoalesce)
  .addRule(builtInIf)
  .addRule(builtInStrlang)
  .addRule(builtInStrdt)
  .addRule(builtInSameterm)
  .addRule(builtInIsiri)
  .addRule(builtInIsuri)
  .addRule(builtInIsblank)
  .addRule(builtInIsliteral)
  .addRule(builtInIsnumeric)
  .addRule(regexExpression)
  .addRule(substringExpression)
  .addRule(strReplaceExpression)
  .addRule(existsFunc)
  .addRule(notExistsFunc)
  .addRule(aggregateCount)
  .addRule(aggregateSum)
  .addRule(aggregateMin)
  .addRule(aggregateMax)
  .addRule(aggregateAvg)
  .addRule(aggregateSample)
  .addRule(aggregateGroup_concat)
  .addRule(aggregate)
  .addRule(iriOrFunction)
  .addRule(rdfLiteral)
  .addRule(numericLiteral)
  .addRule(numericLiteralUnsigned)
  .addRule(numericLiteralPositive)
  .addRule(numericLiteralNegative)
  .addRule(booleanLiteral)
  .addRule(string)
  .addRule(iri)
  .addRule(prefixedName)
  .addRule(blankNode);

export function trySparql12(): void {
  const lexer = ChevSparqlLexer;
  const parser = sparql12Builder.consume(allTokens);

  // Const lexResult = lexer.tokenize('SELECT * WHERE { ?s ?p ?o }');
  const lexResult = lexer.tokenize('SELECT (LANGMATCHES(?S, ?P) AS ?adjusted) WHERE { ?s ?p ?o }');

  parser.input = lexResult.tokens;
  console.log(parser.queryUnit());
  // eslint-disable-next-line no-console
  console.log(parser.errors.join('\n'));
}
