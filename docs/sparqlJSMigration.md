# Migration Guide: SparqlJS to Traqula

In this guide we explain how one can migrate from [sparqljs](https://github.com/RubenVerborgh/SPARQL.js) to [Traqula](../).

Since the AST generated by our parser has a different format than sparqlJS,
Traqula does not form a drop in replacement on AST level.
However, Traqula's AST started from SPARQL Algebras AST drifting away only where necessary.

When you want to migrate from SPARQL.JS to Traqula,
we suggest comparing the [SPARQL.js AST types](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/982edf5d9655b7eca3825d113f90ebdbed4aaa39/types/sparqljs/index.d.ts#L51) to [Traqula AST types](../packages/rules-sparql-1-1/lib/Sparql11types.ts).

In case you do not care about the AST generated, like when you use SparqlJS for query validation,
Traqula _can_ be a drop in replacement.

Using SparqlJS you would parse using:
```typescript
const SparqlParser = require('sparqljs').Parser;
const parser = new SparqlParser();
const parsedQuery = parser.parse(
  'PREFIX foaf: <http://xmlns.com/foaf/0.1/> ' +
  'SELECT * { ?mickey foaf:name "Mickey Mouse"@en; foaf:knows ?other. }');
```

Using Traqula you would write:
```typescript
const SparqlParser = require('@traqula/parser-sparql-1-1').Parser;
const parser = new SparqlParser();
const parsedQuery = parser.parse(
  'PREFIX foaf: <http://xmlns.com/foaf/0.1/> ' +
  'SELECT * { ?mickey foaf:name "Mickey Mouse"@en; foaf:knows ?other. }');
```

Using SparqlJS generation is performed like:
```typescript
const SparqlGenerator = require('sparqljs').Generator;
const generator = new SparqlGenerator({ /* prefixes, baseIRI, factory */ });
const generatedQuery = generator.stringify(parsedQuery);
```

Using Traqula, it [supports round tripping](../engines/parser-sparql-1-1/README.md#collecting-round-tripping-information). When no round-tripping is required:
:
```typescript
const SparqlGenerator = require('@traqula/generator-sparql-1-1').Generator;
const generator = new SparqlGenerator();
const generatedQuery = generator.generate(parsedQuery, { /* prefixes, baseIri, factory, origSource */ });
```

## Differences

Bellow is a non-exhaustive list of differences between SPARQL.js and Traqula's generated AST.
To anyone migrating their code discovering missing information, please consider creating a PR.

### Values key

The object tracking each `VALUES` binding has keys prefixed with `?` in SPARQL.js but not in Traqula.

`VALUES ?var { 'someVal' }` would be converted to:

SPARQLJS:

```json
{
  "type": "values",
  "values": [
    {
      "?var": {
        "termType": "literal",
        "value": "someVal"
      }
    }
  ]
}
```

Traqula:

```json
{
  "type": "values",
  "values": [
    {
      "var": {
        "termType": "literal",
        "value": "someVal"
      }
    }
  ]
}
```

### Type capitalization & subtype referencing

SPARQL.js would contain subtypes such as for `SELECT` nodes like:

```json
{
  "type": "query",
  "queryType": "CONSTRUCT"
}
```

In Traqula these kind of subTypes are normalized to all use the key 'subType' and are always lowercased:

```json
{
  "type": "query",
  "subType": "construct"
}
```

### Iri expansion & Update queries & prefix / base repetitions

SPARQL.js would expand parsed prefixUris by resolving them to the registered `PREFIX` and `BASE`.
Traqula does not perform this expansion itself.
Likewise, SPARQL.js would only keep the latest prefix definition for a given prefix and would merge definitions when parsing update queries.
Traqula does not perform iri expansions, leaving this to the algebra transformer.
It als keeps context entries as a list of entries for each query.

Query
```
PREFIX ex: <https://example.com/>
INSERT DATA { ex:a ex:a ex:a }

PREFIX ex: <https://example.com/other/>
DELETE DATA { ex:a ex:a ex:a }
```

Becomes in SPARQL.js:

```json
{
  "type": "update",
  "prefixes": {
    "ex": "https://example.com/other/"
  },
  "updates": [
    {
      "updateType": "insert",
      "insert": [
        {
          "type": "bgp",
          "triples": [
            {
              "subject": {
                "termType": "NamedNode",
                "value": "https://example.com/a"
              },
              "predicate": {
                "termType": "NamedNode",
                "value": "https://example.com/a"
              },
              "object": {
                "termType": "NamedNode",
                "value": "https://example.com/a"
              }
            }
          ]
        }
      ]
    },
    {
      "type": "delete",
      "delete": [
        {
          "type": "bgp",
          "triple": [
            {
              "subject": {
                "termType": "NamedNode",
                "value": "https://example.com/other/a"
              },
              "predicate": {
                "termType": "NamedNode",
                "value": "https://example.com/other/a"
              },
              "object": {
                "termType": "NamedNode",
                "value": "https://example.com/other/a"
              }
            }
          ]
        }
      ]
    }
  ]
}
```

While Traqula is much more verbose:

```json
{
  "type": "update",
  "updates": [
    {
      "context": [
        {
          "type": "contextDef",
          "subType": "prefix",
          "key": "ex",
          "value": {
            "type": "term",
            "subType": "namedNode",
            "value": "https://example.com/"
          }
        }
      ],
      "operation": {
        "type": "updateOperation",
        "subType": "insertdata",
        "data": [
          {
            "type": "pattern",
            "subType": "bgp",
            "triples": [
              {
                "type": "triple",
                "subject": {
                  "type": "term",
                  "subType": "namedNode",
                  "value": "a",
                  "prefix": "ex"
                },
                "predicate": {
                  "type": "term",
                  "subType": "namedNode",
                  "value": "a",
                  "prefix": "ex"
                },
                "object": {
                  "type": "term",
                  "subType": "namedNode",
                  "value": "a",
                  "prefix": "ex"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "context": [
        {
          "type": "contextDef",
          "subType": "prefix",
          "key": "ex",
          "value": {
            "type": "term",
            "subType": "namedNode",
            "value": "https://example.com/other/"
          }
        }
      ],
      "operation": {
        "type": "updateOperation",
        "subType": "deletedata",
        "data": [
          {
            "type": "pattern",
            "subType": "bgp",
            "triples": [
              {
                "type": "triple",
                "subject": {
                  "type": "term",
                  "subType": "namedNode",
                  "value": "a",
                  "prefix": "ex"
                },
                "predicate": {
                  "type": "term",
                  "subType": "namedNode",
                  "value": "a",
                  "prefix": "ex"
                },
                "object": {
                  "type": "term",
                  "subType": "namedNode",
                  "value": "a",
                  "prefix": "ex"
                }
              }
            ]
          }
        ]
      }
    }
  ]
}
```

The reason for changing this is to create an AST that is not too invasive and sticks to providing a tree representation of the grammar.
By creating a more consistent AST, Traqula is able to provide an efficient yet generic transformer allowing you to visit or manipulate teh AST. The code bellow aggregates the prefix entries into a similar object as that of SPARQL.js:

```typescript
import { AstTransformer } from "@traqula/rules-sparql-1-1";
const transformer = new AstTransformer();
const context: Record<string, string> = {};
transformer.visitNodeSpecific(ast, {}, {
  // Visit nodes of type contextDef
  'contextDef': {
    // Visit the nodes of subType prefix
    'prefix': {
      visitor: (prefixDef) => {
        context[prefixDef.key] = prefixDef.value.value;
      }
    }
  }
})
```

### Generation of Prefixes

In SPARQL.js you could provide a context entry to the generator which could contain prefixes and the generator would generate them as such.
In Traqula we do not support such an operation and expect you instead to manipulate the AST directly.
Meaning in Traqula you write:

```typescript
import { Generator } from '@traqula/generator-sparql-1-1';
import { AstTransformer, Astfactory, QuerySelect } from '@traqula/rules-sparql-1-1';
const query: QuerySelect;
const generator = new Generator();
const F = new AstFactory();
query.context.append(
  F.contextDefinitionPrefix(
    F.gen(),
    'ex',
    F.termNamed(F.gen(), 'https://example.com/'))
);
```

> [!note]
> The arguments `F.gen()` create a sourceLocation definition which is a [part of our AST](./usage/AST-structure.md#source-location) for [round tripping purposes](modifications/create-generator.md#round-tripping).
> `F.gen()` simply says to the generator that it should generate this node.
