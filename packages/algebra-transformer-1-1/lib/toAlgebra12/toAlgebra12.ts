import type * as RDF from '@rdfjs/types';
import { IndirBuilder } from '@traqula/core';
import type * as T11 from '@traqula/rules-sparql-1-1';
import type { SparqlQuery, Term, TripleCollection, TripleNesting } from '@traqula/rules-sparql-1-2';
import { termToString } from 'rdf-string';
import Factory from '../factory';
import type { Algebra } from '../index';
import type { AlgebraIndir, FlattenedTriple } from '../toAlgebra/core';
import { createAlgebraContext } from '../toAlgebra/core';
import { translateTerm } from '../toAlgebra/general';
import type { translateQuery } from '../toAlgebra/toAlgebra';
import { sparqlAlgebraTransformerBuilder } from '../toAlgebra/toAlgebra';
import { translateTripleCollection, translateTripleNesting } from '../toAlgebra/tripleAndQuad';

const reificationIri = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#reifies';

export const translateTerm12: AlgebraIndir<(typeof translateTerm)['name'], RDF.Term, [Term]> = {
  name: 'translateTerm',
  fun: s => (c, term) => {
    if (term.subType === 'triple') {
      return c.dataFactory.quad(
        s.SUBRULE(translateTerm12, term.subject),
        s.SUBRULE(translateTerm12, term.predicate),
        s.SUBRULE(translateTerm12, term.object),
      );
    }
    return translateTerm.fun(s)(c, term);
  },
};

export const translateTripleCollection12:
AlgebraIndir<(typeof translateTripleCollection)['name'], void, [TripleCollection, FlattenedTriple[]]> = {
  name: 'translateTripleCollection',
  fun: s => (c, collection, result) => {
    if (collection.subType === 'reifiedTriple') {
      const { SUBRULE } = s;
      const { dataFactory } = c;
      const translated: FlattenedTriple[] = [];
      SUBRULE(translateTripleNesting12, collection.triples[0], translated);
      const { subject, predicate, object } = translated[0];
      const asTerm = dataFactory.quad(subject, <Exclude<typeof predicate, T11.PathPure>> predicate, object);
      result.push({
        subject,
        predicate: dataFactory.namedNode(reificationIri),
        object: asTerm,
      });
    } else {
      translateTripleCollection.fun(s)(c, <T11.TripleCollection> collection, result);
    }
  },
};

export const translateTripleNesting12:
AlgebraIndir<(typeof translateTripleNesting)['name'], void, [TripleNesting, FlattenedTriple[]]> = {
  name: 'translateTripleNesting',
  fun: s => (c, triple, result) => {
    translateTripleNesting.fun(s)(c, <T11.TripleNesting>triple, result);
    const SUBRULE = s.SUBRULE;
    const { subject, predicate, object } = result.at(-1)!;
    const { astFactory: F, dataFactory } = c;
    if (triple.annotations && triple.annotations.length > 0) {
      // Blocks know who identifies them. -> Can just add it to list of triples
      //  -> a blocks identifier only need to be registered when the identifier is not explicitly registered before.
      //  We register: <annotationNode, reifies, tripleNesting>
      // You cannot have an annotation on a triple that has paths
      const asTerm = dataFactory.quad(subject, <Exclude<typeof predicate, T11.PathPure>> predicate, object);
      const registered = new Set<string>();
      for (const annotation of triple.annotations) {
        let subject: RDF.Term;
        if (F.isTripleCollection(annotation)) {
          subject = SUBRULE(translateTerm12, annotation.identifier);
          if (registered.has(termToString(subject))) {
            continue;
          }
        } else {
          subject = SUBRULE(translateTerm12, annotation);
        }
        registered.add(termToString(subject));
        result.push({
          subject,
          predicate: dataFactory.namedNode(reificationIri),
          object: asTerm,
        });
      }
    }
  },
};

export const sparqlAlgebraTransformerBuilder12 = IndirBuilder
  .create(sparqlAlgebraTransformerBuilder)
  .patchRule(translateTerm12)
  .patchRule(translateTripleCollection12)
  .patchRule(translateTripleNesting12)
  .typePatch<{
    [translateQuery.name]: [Algebra.Operation, [SparqlQuery, boolean | undefined, boolean | undefined]];
  }>();

/**
 * Translates the given SPARQL query to SPARQL Algebra.
 * @param query - sparql AST generated by Traqula
 * @param options - Optional options object. Current options:
 * @param options.dataFactory - The Datafactory used to generate terms. Default @rdfjs/data-model.
 * @param options.quads - Boolean indicating whether triples should be converted to Quads
 *        (consumes GRAPH statements). Default false.
 * @param options.prefixes - Pre-defined prefixes for the given query. Default empty.
 * @param options.baseIRI - Base IRI that should be used for the query.
 *        Default undefined (throws error if required).
 * @param options.blankToVariable - translate all blank nodes into variables
 * @returns Operation
 */
export default function translate12(query: SparqlQuery, options: {
  dataFactory?: RDF.DataFactory;
  quads?: boolean;
  prefixes?: Record<string, string>;
  baseIRI?: string;
  blankToVariable?: boolean;
} = {}): Algebra.Operation {
  const c = createAlgebraContext(new Factory(options.dataFactory));
  const transformer = sparqlAlgebraTransformerBuilder12.build();
  return transformer.translateQuery(c, query, options.quads, options.blankToVariable);
}
