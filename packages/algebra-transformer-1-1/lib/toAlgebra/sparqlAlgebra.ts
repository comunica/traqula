import type * as RDF from '@rdfjs/types';
import type { PatternGroup, SparqlQuery } from '@traqula/rules-sparql-1-1';
import Factory from '../factory';
import type { Algebra } from '../index';
import { translateAggregates } from './aggregate';
import { type AlgebraContext, createAlgebraContext } from './core';
import { findAllVariables, registerContextDefinitions, translateBlankNodesToVariables } from './general';
import { translateGraphPattern } from './patterns';
import { translateUpdate } from './updates';

export function translateQuery(
  c: AlgebraContext,
  sparql: SparqlQuery,
  quads?: boolean,
  blankToVariable?: boolean,
): Algebra.Operation {
  const F = c.astFactory;
  c.variables = new Set();
  c.varCount = 0;
  c.useQuads = quads ?? false;

  let result: Algebra.Operation;

  // Find ALL variables here to fill `variables` array - needed to create fresh variables
  findAllVariables(c, sparql);

  if (F.isQuery(sparql)) {
    registerContextDefinitions(c, sparql.context);
    // Group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE
    const group: PatternGroup = sparql.where ?? F.patternGroup([], F.gen());
    result = translateGraphPattern(c, group);
    // 18.2.4 Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions
    result = translateAggregates(c, sparql, result);
  } else {
    result = translateUpdate(c, sparql);
  }
  if (blankToVariable) {
    result = translateBlankNodesToVariables(c, result);
  }

  return result!;
}

/**
 * Translates the given SPARQL query to SPARQL Algebra.
 * @param query - sparql AST generated by Traqula
 * @param options - Optional options object. Current options:
 * @param options.dataFactory - The Datafactory used to generate terms. Default @rdfjs/data-model.
 * @param options.quads - Boolean indicating whether triples should be converted to Quads
 *        (consumes GRAPH statements). Default false.
 * @param options.prefixes - Pre-defined prefixes for the given query. Default empty.
 * @param options.baseIRI - Base IRI that should be used for the query.
 *        Default undefined (throws error if required).
 * @param options.blankToVariable - translate all blank nodes into variables
 * @returns Operation
 */
export default function translate(query: SparqlQuery, options: {
  dataFactory?: RDF.DataFactory;
  quads?: boolean;
  prefixes?: Record<string, string>;
  baseIRI?: string;
  blankToVariable?: boolean;
} = {}): Algebra.Operation {
  const c = createAlgebraContext(new Factory(options.dataFactory));
  return translateQuery(c, query, options.quads, options.blankToVariable);
}
