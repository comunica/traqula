import type * as RDF from '@rdfjs/types';
import { Transformer } from '@traqula/core';
import {
  Factory as AstFactory,
} from '@traqula/rules-sparql-1-1';
import type {
  BasicGraphPattern,
  Expression,
  GraphQuads,
  Ordering,
  Path,
  PathNegatedElt,
  PathPure,
  Pattern,
  PatternBgp,
  PatternGroup,
  Query,
  Sparql11Nodes,
  SparqlQuery,
  Term,
  TermVariable,
  TripleCollection,
  TripleNesting,
  Wildcard,
} from '@traqula/rules-sparql-1-1';
import equal from 'fast-deep-equal/es6';
import { DataFactory } from 'rdf-data-factory';
import { termToString } from 'rdf-string';
import * as Algebra from './algebra';
import Factory from './factory';
import Util from './util';

const Parser = require('sparqljs').Parser;

const types = Algebra.Types;
const typeVals = Object.values(types);

type mapAggregateType = TermVariable | Wildcard | Expression | Ordering;
type TempDelIns = (PatternBgp | GraphQuads)[];

/**
 * Translates the given SPARQL query to SPARQL Algebra.
 * @param query - Either a SPARQL string or an object generated by sparql.js
 * @param options - Optional options object. Current options:
 *    * @param options.dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.
 *    * @param options.quads: Boolean indicating whether triples should be converted to Quads
 *        (consumes GRAPH statements). Default false.
 *    * @param options.prefixes: Pre-defined prefixes for the given query. Default empty.
 *    * @param options.baseIRI: Base IRI that should be used for the query.
 *        Default undefined (throws error if required).
 * @returns {Operation}
 */
export default function translate(query: SparqlQuery, options: {
  dataFactory?: RDF.DataFactory;
  quads?: boolean;
  prefixes?: Record<string, string>;
  baseIRI?: string;
  blankToVariable?: boolean;
} = {}): Algebra.Operation {
  const queryTranslator = new QueryTranslator(new Factory(options.dataFactory));

  return queryTranslator.translateQuery(query, options.quads, options.blankToVariable);
}

class QueryTranslator {
  /**
   * This set is filled in during the inScopeVariables call
   */
  private variables = new Set<string>();
  private varCount = 0;
  private useQuads = false;
  private readonly transformer = new Transformer<Sparql11Nodes>();
  private readonly astFactory = new AstFactory();
  private readonly dataFactory = new DataFactory();

  public constructor(private readonly factory: Factory) {}

  public translateQuery(sparql: SparqlQuery, quads?: boolean, blankToVariable?: boolean): Algebra.Operation {
    this.variables = new Set();
    this.varCount = 0;
    this.useQuads = quads ?? false;

    let result: Algebra.Operation;

    // Find ALL variables here to fill `variables` array
    this.findAllVariables(sparql);

    if (this.astFactory.isQuery(sparql)) {
      // Group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE
      const group: PatternGroup = sparql.where ?? this.astFactory.patternGroup([], this.astFactory.sourceLocation());
      result = this.translateGraphPattern(group);
      result = this.translateAggregates(sparql, result);
    } else if (sparql.type === 'update') {
      result = this.translateUpdate(sparql);
    }
    if (blankToVariable) {
      result = this.translateBlankNodesToVariables(result!);
    }

    return result!;
  }

  public isString(str: any): str is string {
    return typeof str === 'string';
  }

  private isTerm(term: any): term is RDF.Term {
    return Boolean(term?.termType);
  }

  // This is not completely correct but this way we also catch SPARQL.js triples
  private isTriple(triple: any): triple is RDF.Quad {
    return triple.subject && triple.predicate && triple.object;
  }

  private isVariable(term: any): term is RDF.Variable {
    return term?.termType === 'Variable';
  }

  // Will be used to make sure new variables don't overlap
  private findAllVariables(thingy: object): void {
    this.transformer.visitObjects(thingy, (current) => {
      if (this.astFactory.alwaysSparql11(current)) {
        if (this.astFactory.isTermVariable(current)) {
          this.variables.add(current.value);
        } else if (this.astFactory.isPatternValues(current)) {
          for (const key in current.values.at(0) ?? {}) {
            this.variables.add(key);
          }
        }
      }
    });
  }

  // 18.2.1
  private inScopeVariables(thingy: SparqlQuery | Pattern | PropertyPath | RDF.Term): Record<string, RDF.Variable> {
    const inScope: Record<string, RDF.Variable> = {};

    if (this.isTriple(thingy)) {
      // Note that this could both be an actual Quad or a SPARQL.js triple (without graph)
      const result = [
        this.inScopeVariables(thingy.subject),
        this.inScopeVariables(thingy.predicate),
        this.inScopeVariables(thingy.object),
        thingy.graph ? this.inScopeVariables(thingy.graph) : {},
      ];
      Object.assign(inScope, ...result);
    } else if (this.isTerm(thingy)) {
      if (this.isVariable(thingy)) {
        inScope[thingy.value] = thingy;
      }
    } else if (thingy.type === 'bgp') {
      // Slightly cheating but this is a subset of what we support so is fine
      const quads = <RDF.Quad[]> thingy.triples;
      Object.assign(inScope, ...quads.map(this.inScopeVariables));
    } else if (thingy.type === 'path') {
      // A path predicate should not have variables but just iterating so we could theoretically support this
      Object.assign(inScope, ...thingy.items.map(this.inScopeVariables));
    } else if (thingy.type === 'group' || thingy.type === 'union' || thingy.type === 'optional') {
      Object.assign(inScope, ...thingy.patterns.map(this.inScopeVariables));
    } else if (thingy.type === 'service' || thingy.type === 'graph') {
      Object.assign(inScope, this.inScopeVariables(thingy.name));
      Object.assign(inScope, ...thingy.patterns.map(this.inScopeVariables));
    } else if (thingy.type === 'bind') {
      Object.assign(inScope, this.inScopeVariables(thingy.variable));
    } else if (thingy.type === 'values') {
      if (thingy.values.length > 0) {
        const vars = Object.keys(thingy.values[0]).map(v => this.factory.createTerm(v));
        Object.assign(inScope, ...vars.map(this.inScopeVariables));
      }
    } else if (thingy.type === 'query' && (thingy.queryType === 'SELECT' || thingy.queryType === 'DESCRIBE')) {
      if (thingy.where && thingy.variables.some(Util.isWildcard)) {
        Object.assign(inScope, ...thingy.where.map(this.inScopeVariables));
      }
      for (const v of thingy.variables) {
        if (this.isVariable(v)) {
          Object.assign(inScope, this.inScopeVariables(v));
        } else if ((<VariableExpression> v).variable) {
          Object.assign(inScope, this.inScopeVariables((<VariableExpression> v).variable));
        }
      }
      if (thingy.queryType === 'SELECT') {
        if (thingy.group) {
          // Grouping can be a VariableExpression, typings are wrong
          for (const g of thingy.group) {
            if ((<VariableExpression> g).variable) {
              Object.assign(inScope, this.inScopeVariables((<VariableExpression> g).variable));
            }
          }
        }
        if (thingy.values) {
          const values: ValuesPattern = { type: 'values', values: thingy.values };
          Object.assign(inScope, this.inScopeVariables(values));
        }
      }
    }

    return inScope;
  }

  /**
   * 18.2.2.1: Expand Syntax Forms - partly done by sparql parser, partly here, and partly in BGP
   * https://www.w3.org/TR/sparql11-query/#sparqlExpandForms
   * https://www.w3.org/TR/sparql11-query/#QSynIRI
   */
  private expandNamedNodes<Node extends Sparql11Nodes>(node: Node): Node {
    const F = this.astFactory;
    return <Node> this.transformer.transformNodeSpecific(node, 'term', 'namedNode', (cur) => {
      if (F.isTermNamedPrefixed(cur)) {
        // TODO: relate yourself prefix
        return cur;
      }
      // TODO: relate yourself to base
      return cur;
    });
  }

  private translateGraphPattern(pattern: Pattern): Algebra.Operation {
    pattern = this.expandNamedNodes(pattern);

    if (this.astFactory.isPatternBgp(pattern)) {
      return this.translateBgp(pattern);
    }

    // 18.2.2.6 - GroupOrUnionGraphPattern
    if (pattern.type === 'union') {
      return this.factory.createUnion(pattern.patterns.map((p: any) => {
        // Sparqljs doesn't always indicate the children are groups
        if (p.type !== 'group') {
          p = { type: 'group', patterns: [ p ]};
        }
        return this.translateGraphPattern(p);
      }));
    }

    // 18.2.2.6 - GraphGraphPattern
    if (pattern.type === 'graph') {
      // Sparql.js combines the group graph pattern and the graph itself in the same object.
      // We split here so the group graph pattern can be interpreted correctly.
      const group: GroupPattern = { type: 'group', patterns: pattern.patterns };
      let result = this.translateGraphPattern(group);

      // Output depends on if we use quads or not
      if (this.useQuads) {
        result = this.recurseGraph(result, pattern.name);
      } else {
        result = this.factory.createGraph(result, pattern.name);
      }

      return result;
    }

    // 18.2.2.6 - InlineData
    if (pattern.type === 'values') {
      return this.translateInlineData(pattern);
    }

    // 18.2.2.6 - SubSelect
    if (pattern.type === 'query') {
      return this.translateQuery(pattern, this.useQuads, false);
    }

    if (pattern.type === 'group') {
      // 18.2.2.2
      const filters: FilterPattern[] = [];
      const nonfilters: Pattern[] = [];
      for (const pattern of pattern.patterns) {
        (pattern.type === 'filter' ? filters : nonfilters).push(pattern);
      }

      // 18.2.2.6 - GroupGraphPattern
      let result = nonfilters.reduce(this.accumulateGroupGraphPattern, this.factory.createBgp([]));

      // 18.2.2.7
      const expressions: Algebra.Expression[] = filters.map(filter => this.translateExpression(filter.expression));
      if (expressions.length > 0) {
        result = this.factory.createFilter(
          result,
          expressions.reduce((acc, exp) => this.factory.createOperatorExpression('&&', [ acc, exp ])),
        );
      }

      return result;
    }

    throw new Error(`Unexpected type: ${pattern.type}`);
  }

  private translateExpression(exp: Expression | RDF.Term | Wildcard): Algebra.Expression {
    if (Util.isSimpleTerm(exp)) {
      return this.factory.createTermExpression(exp);
    }
    if (Util.isQuad(exp)) {
      if (Util.hasQuadVariables(exp)) {
        return this.factory.createOperatorExpression('triple', [
          this.translateExpression(exp.subject),
          this.translateExpression(exp.predicate),
          this.translateExpression(exp.object),
        ]);
      }
      return this.factory.createTermExpression(exp);
    }
    if (Util.isWildcard(exp)) {
      return this.factory.createWildcardExpression();
    }
    if ('aggregation' in exp) {
      return this.factory.createAggregateExpression(
        exp.aggregation,
        this.translateExpression(exp.expression),
        Boolean(exp.distinct),
        exp.separator,
      );
    }
    if ('function' in exp) {
      // Outdated typings
      return this.factory.createNamedExpression(<RDF.NamedNode><unknown> exp.function, exp.args.map(this.translateExpression));
    }
    if ('operator' in exp) {
      if (exp.operator === 'exists' || exp.operator === 'notexists') {
        return this.factory.createExistenceExpression(
          exp.operator === 'notexists',
          this.translateGraphPattern(<Pattern> exp.args[0]),
        );
      }
      if (exp.operator === 'in' || exp.operator === 'notin') {
        exp.args = [ exp.args[0], exp.args[1] ];
      }
      // Sparql.js uses 2 arguments with the second one being a list
      return this.factory.createOperatorExpression(exp.operator, exp.args.map(<any> this.translateExpression));
    }
    throw new Error(`Unknown expression: ${JSON.stringify(exp)}`);
  }

  private translateTerm(term: Term): RDF.Term {
    const F = this.astFactory;
    const dataFact = this.dataFactory;
    if (F.isTermNamed(term)) {
      return dataFact.namedNode(term.value);
    }
    if (F.isTermBlank(term)) {
      return dataFact.blankNode(term.label);
    }
    if (F.isTermVariable(term)) {
      return dataFact.variable(term.value);
    }
    throw new Error(`Unexpected term: ${JSON.stringify(term)}`);
  }

  private translateTripleCollection(collection: TripleCollection, result: Algebra.Triple[]): void {
    this.translateBasicGraphPattern(collection.triples, result);
  }

  private translateTripleNesting(triple: TripleNesting, result: Algebra.Triple[]): void {
    const F = this.astFactory;
    let subject: RDF.Term;
    const predicate: RDF.Term | Path = <any> undefined;
    let object: RDF.Term;
    if (F.isTripleCollection(triple.subject)) {
      this.translateTripleCollection(triple.subject, result);
      subject = this.translateTerm(triple.subject.identifier);
    } else {
      subject = this.translateTerm(triple.subject);
    }

    // TODO: what is the path?

    if (F.isTripleCollection(triple.object)) {
      this.translateTripleCollection(triple.object, result);
      object = this.translateTerm(triple.object.identifier);
    } else {
      object = this.translateTerm(triple.object);
    }

    result.push({
      subject,
      predicate,
      object,
    });
  }

  private translateBasicGraphPattern(triples: BasicGraphPattern, result: Algebra.Triple[]): void {
    const F = this.astFactory;
    for (const triple of triples) {
      if (F.isTripleCollection(triple)) {
        this.translateBasicGraphPattern(triple.triples, result);
      } else {
        this.translateTripleNesting(triple, result);
      }
    }
  }

  /**
   * 18.2.2.1: Expand Syntax Forms: Flatten TripleCollection
   * 18.2.2.3: Translate Property Path Expressions
   * 18.2.2.4: Translate Property Path Patterns
   * 18.2.2.5: Translate Basic Graph Patterns
   * TODO: In the ast, a group with a single BGP in it is a single object. (TODO: not anymore)
   */
  private translateBgp(bgp: PatternBgp): Algebra.Operation {
    let patterns: Algebra.Pattern[] = [];
    const joins: Algebra.Operation[] = [];
    const flattenedTriples: Algebra.Triple[] = [];
    this.translateBasicGraphPattern(bgp.triples, flattenedTriples);
    for (const triple of flattenedTriples) {
      if (this.astFactory.isPathPure(triple.predicate)) {
        // TranslatePath returns a mix of Quads and Paths
        const path = this.translatePath(triple);
        for (const p of path) {
          if (p.type === types.PATH) {
            if (patterns.length > 0) {
              joins.push(this.factory.createBgp(patterns));
            }
            patterns = [];
            joins.push(p);
          } else {
            patterns.push(p);
          }
        }
      } else {
        patterns.push(this.translateQuad(triple));
      }
    }
    if (patterns.length > 0) {
      joins.push(this.factory.createBgp(patterns));
    }
    if (joins.length === 1) {
      return joins[0];
    }
    return this.factory.createJoin(joins);
  }

  /**
   * 18.2.2.3 Translate Property Path Expressions
   * 18.2.2.4 Translate Property Path Patterns
   */
  private translatePath(triple: Algebra.Triple & { predicate: RDF.NamedNode | PathPure }):
  (Algebra.Path | Algebra.Pattern)[] {
    const sub = triple.subject;
    const pred = this.translatePathPredicate(triple.predicate);
    const obj = triple.object;

    return this.simplifyPath(sub, pred, obj);
  }

  /**
   * 18.2.2.3 Translate Property Path Expressions
   */
  private translatePathPredicate(predicate: RDF.NamedNode | PathPure): Algebra.PropertyPathSymbol {
    // Iri -> link(iri)
    if (this.isTerm(predicate)) {
      return this.factory.createLink(predicate);
    }

    // ^path -> inv(path)
    if (predicate.subType === '^') {
      return this.factory.createInv(this.translatePathPredicate(<RDF.NamedNode | PathPure> predicate.items[0]));
    }

    if (predicate.subType === '!') {
      // Negation is either over a single predicate or a list of disjuncted properties - that can only have modifier '^'
      const normals: RDF.NamedNode[] = [];
      const inverted: RDF.NamedNode[] = [];
      // Either the item of this one is an `|`, `^` or `iri`
      const contained = predicate.items[0];
      let items: (RDF.NamedNode | PathNegatedElt)[];
      if (this.astFactory.isPathPure(contained) && contained.subType === '|') {
        items = <(RDF.NamedNode | PathNegatedElt)[]> contained.items;
      } else {
        items = [ <RDF.NamedNode | PathNegatedElt> contained ];
      }

      for (const item of items) {
        if (this.isTerm(item)) {
          normals.push(item);
        } else if (item.subType === '^') {
          inverted.push(<RDF.NamedNode> <unknown> item.items[0]);
        } else {
          throw new Error(`Unexpected item: ${JSON.stringify(item)}`);
        }
      }

      // NPS elements do not have the LINK function
      const normalElement = this.factory.createNps(normals);
      const invertedElement = this.factory.createInv(this.factory.createNps(inverted));

      // !(:iri1|...|:irin) -> NPS({:iri1 ... :irin})
      if (inverted.length === 0) {
        return normalElement;
      }
      // !(^:iri1|...|^:irin) -> inv(NPS({:iri1 ... :irin}))
      if (normals.length === 0) {
        return invertedElement;
      }
      // !(:iri1|...|:irii|^:irii+1|...|^:irim -> alt(NPS({:iri1 ...:irii}), inv(NPS({:irii+1, ..., :irim})) )
      return this.factory.createAlt([ normalElement, invertedElement ]);
    }

    // Path1 / path -> seq(path1, path2)
    if (predicate.subType === '/') {
      return this.factory.createSeq(predicate.items.map(item => this.translatePathPredicate(<PathPure> item)));
    }
    // Path1 | path2 -> alt(path1, path2)
    if (predicate.subType === '|') {
      return this.factory.createAlt(predicate.items.map(item => this.translatePathPredicate(<PathPure> item)));
    }
    // Path* -> ZeroOrMorePath(path)
    if (predicate.subType === '*') {
      return this.factory.createZeroOrMorePath(this.translatePathPredicate(<PathPure> predicate.items[0]));
    }
    // Path+ -> OneOrMorePath(path)
    if (predicate.subType === '+') {
      return this.factory.createOneOrMorePath(this.translatePathPredicate(<PathPure> predicate.items[0]));
    }
    // Path? -> ZeroOrOnePath(path)
    if (predicate.subType === '?') {
      return this.factory.createZeroOrOnePath(this.translatePathPredicate(<PathPure> predicate.items[0]));
    }

    throw new Error(`Unable to translate path expression ${JSON.stringify(predicate)}`);
  }

  /**
   * 18.2.2.4 Translate Property Path Patterns
   */
  private simplifyPath(
    subject: RDF.Term,
    predicate: Algebra.PropertyPathSymbol,
    object: RDF.Term,
  ): (Algebra.Pattern | Algebra.Path)[] {
    // X link(iri) Y -> X iri Y
    if (predicate.type === types.LINK) {
      return [ this.factory.createPattern(subject, predicate.iri, object) ];
    }

    // X inv(iri) Y -> Y iri X
    if (predicate.type === types.INV) {
      return this.simplifyPath(<RDF.Quad_Subject> object, predicate.path, subject);
    }

    // X seq(P, Q) Y -> X P ?V . ?V Q P
    if (predicate.type === types.SEQ) {
      let iter = subject;
      const result: (Algebra.Pattern | Algebra.Path)[] = [];
      for (const pathOfSeq of predicate.input.slice(0, -1)) {
        const joinVar = this.generateFreshVar();
        result.push(...this.simplifyPath(iter, pathOfSeq, joinVar));
        iter = joinVar;
      }
      result.push(...this.simplifyPath(iter, predicate.input.at(-1)!, object));
      return result;
    }

    // X P Y -> Path(X, P, Y)
    return [ this.factory.createPath(subject, predicate, object) ];
  }

  private generateFreshVar(): RDF.Variable {
    let newVar = `var${this.varCount++}`;
    while (this.variables.has(newVar)) {
      newVar = `var${this.varCount++}`;
    }
    this.variables.add(newVar);
    return this.dataFactory.variable(newVar);
  }

  private translateQuad(quad: Algebra.Triple): Algebra.Pattern {
    if (this.astFactory.isPathPure(quad.predicate)) {
      throw new Error('Trying to translate property path to quad.');
    }
    // Graphs are needed here
    // TODO: investigate if typings are wrong or if we internally add graphs to these
    return this.factory.createPattern(quad.subject, quad.predicate, quad.object, (<any> quad).graph);
  }

  private recurseGraph(thingy: Algebra.Operation, graph: RDF.Term, replacement?: RDF.Variable): Algebra.Operation {
    if (thingy.type === types.GRAPH) {
      if (replacement) {
        // At this point we would lose track of the replacement which would result in incorrect results
        // This would indicate the library is not being used as intended though
        throw new Error('Recursing through nested GRAPH statements with a replacement is impossible.');
      }
      // In case there were nested GRAPH statements that were not recursed yet for some reason
      thingy = this.recurseGraph(thingy.input, thingy.name);
    } else if (thingy.type === types.SERVICE) {
      // Service blocks are not affected by enclosing GRAPH statements, so nothing is modified in this block.
      // See https://github.com/joachimvh/SPARQLAlgebra.js/pull/104#issuecomment-1838016303
    } else if (thingy.type === types.BGP) {
      thingy.patterns = thingy.patterns.map((quad) => {
        if (replacement) {
          if (quad.subject.equals(graph)) {
            quad.subject = replacement;
          }
          if (quad.predicate.equals(graph)) {
            quad.predicate = replacement;
          }
          if (quad.object.equals(graph)) {
            quad.object = replacement;
          }
        }
        if (quad.graph.termType === 'DefaultGraph') {
          quad.graph = graph;
        }
        return quad;
      });
    } else if (thingy.type === types.PATH) {
      if (replacement) {
        if (thingy.subject.equals(graph)) {
          thingy.subject = replacement;
        }
        if (thingy.object.equals(graph)) {
          thingy.object = replacement;
        }
      }
      if (thingy.graph.termType === 'DefaultGraph') {
        thingy.graph = graph;
      }
    } else if (thingy.type === types.PROJECT && !replacement) {
      // Need to replace variables in subqueries should the graph also be a variable of the same name
      // unless the subquery projects that variable
      if (!thingy.variables.some(v => v.equals(graph))) {
        replacement = this.generateFreshVar();
      }
      thingy.input = this.recurseGraph(thingy.input, graph, replacement);
    } else if (thingy.type === types.EXTEND && !replacement) {
      // This can happen if the query extends an expression to the name of the graph
      // since the extend happens here there should be no further occurrences of this name
      // if there are it's the same situation as above
      if (thingy.variable.equals(graph)) {
        replacement = this.generateFreshVar();
      }
      thingy.input = this.recurseGraph(thingy.input, graph, replacement);
    } else {
      for (const key of Object.keys(thingy)) {
        if (Array.isArray(thingy[key])) {
          thingy[key] = thingy[key].map((x: any) => this.recurseGraph(x, graph, replacement));
        } else if (this.typeVals.includes(thingy[key].type)) {
          // Can't do instanceof on an interface
          thingy[key] = this.recurseGraph(thingy[key], graph, replacement);
        } else if (replacement && this.isVariable(thingy[key]) && thingy[key].equals(graph)) {
          thingy[key] = replacement;
        }
      }
    }

    return thingy;
  }

  private accumulateGroupGraphPattern(G: Algebra.Operation, E: Pattern): Algebra.Operation {
    if (E.type === 'optional') {
      // Optional input needs to be interpreted as a group
      const A = this.translateGraphPattern({ type: 'group', patterns: E.patterns });
      if (A.type === types.FILTER) {
        G = this.factory.createLeftJoin(G, A.input, A.expression);
      } else {
        G = this.factory.createLeftJoin(G, A);
      }
    } else if (E.type === 'minus') {
      // Minus input needs to be interpreted as a group
      const A = this.translateGraphPattern({ type: 'group', patterns: E.patterns });
      G = this.factory.createMinus(G, A);
    } else if (E.type === 'bind') {
      G = this.factory.createExtend(G, E.variable, this.translateExpression(E.expression));
    } else if (E.type === 'service') {
      // Transform to group so childnodes get parsed correctly
      const group: GroupPattern = { type: 'group', patterns: E.patterns };
      const A = this.factory.createService(this.translateGraphPattern(group), E.name, E.silent);
      G = this.simplifiedJoin(G, A);
    } else {
      const A = this.translateGraphPattern(E);
      G = this.simplifiedJoin(G, A);
    }

    return G;
  }

  private simplifiedJoin(G: Algebra.Operation, A: Algebra.Operation): Algebra.Operation {
    // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.
    if (G.type === types.BGP && A.type === types.BGP) {
      G = this.factory.createBgp([ ...G.patterns, ...A.patterns ]);
    } else if (G.type === types.BGP && G.patterns.length === 0) {
      // 18.2.2.8 (simplification)
      G = A;
    } else if (A.type === types.BGP && A.patterns.length === 0) {
      // Do nothing
    } else {
      G = this.factory.createJoin([ G, A ]);
    }
    return G;
  }

  private translateInlineData(values: any): Algebra.Values {
    const variables = <RDF.Variable[]>(values.values.length === 0 ?
        [] :
      Object.keys(values.values[0])).map(this.factory.createTerm.bind(this.factory));
    const bindings = values.values.map((binding: any) => {
      let keys = Object.keys(binding);
      keys = keys.filter(k => binding[k] !== undefined);
      const map: any = {};
      for (const key of keys) {
        map[key] = binding[key];
      }
      return map;
    });
    return this.factory.createValues(variables, bindings);
  }

  // --------------------------------------- AGGREGATES
  private translateAggregates(query: Query, res: Algebra.Operation): Algebra.Operation {
    // Typings for ConstructQuery are wrong and missing several fields
    // so we will cast quite often to SelectQuery to have partial typings
    const select = <SelectQuery> query;

    // 18.2.4.1
    const E: VariableExpression[] = [];

    const A: NodeJS.Dict<AggregateExpression> = {};
    select.variables = select.variables && select.variables.map(val => this.mapAggregate(val, A));
    select.having = select.having && select.having.map(val => this.mapAggregate(val, A));
    select.order = select.order && select.order.map(val => this.mapAggregate(val, A));

    // If there are any aggregates or if we have a groupBy (both result in a GROUP)
    if (select.group ?? Object.keys(A).length > 0) {
      const aggregates = Object.keys(A).map(v =>
        this.translateBoundAggregate(<AggregateExpression> A[v], <RDF.Variable> this.factory.createTerm(v)));
      const vars: RDF.Variable[] = [];
      if (select.group) {
        for (const e of select.group) {
          if (Util.isSimpleTerm(e.expression)) {
            // This will always be a var, otherwise sparql would be invalid
            vars.push(<RDF.Variable>e.expression);
          } else {
            // Incorrect typings, e can have a variable, see for example group-variable test in sparql.js
            const v = 'variable' in e ? <RDF.Variable>(<any> e).variable : this.generateFreshVar();
            res = this.factory.createExtend(res, v, this.translateExpression(e.expression));
            vars.push(v);
          }
        }
      }
      res = this.factory.createGroup(res, vars, aggregates);
    }

    // 18.2.4.2
    if (select.having) {
      for (const filter of select.having) {
        res = this.factory.createFilter(res, this.translateExpression(filter));
      }
    }

    // 18.2.4.3
    if (query.values) {
      res = this.factory.createJoin([ res, this.translateInlineData(query) ]);
    }

    // 18.2.4.4
    let PV: (RDF.Variable | RDF.NamedNode)[] = [];

    if (query.queryType === 'SELECT' || query.queryType === 'DESCRIBE') {
      // Sort variables for consistent output
      if (query.variables.some((e: any) => e && Util.isWildcard(e))) {
        PV = Object.values(this.inScopeVariables(query))
          .sort((left, right) => left.value.localeCompare(right.value));
      } else {
        // Wildcard has been filtered out above
        for (const v of <Variable[]> query.variables) {
          // Can have non-variables with DESCRIBE
          if (this.isVariable(v) || !('variable' in v)) {
            PV.push(v);
          } else if (v.variable) {
            // ... AS ?x
            PV.push(v.variable);
            E.push(v);
          }
        }
      }
    }

    // TODO: Jena simplifies by having a list of extends
    for (const v of E) {
      res = this.factory.createExtend(res, v.variable, this.translateExpression(v.expression));
    }

    // 18.2.5
    // not using toList and toMultiset

    // 18.2.5.1
    if (select.order) {
      res = this.factory.createOrderBy(res, select.order.map((exp: any) => {
        let result = this.translateExpression(exp.expression);
        if (exp.descending) {
          result = this.factory.createOperatorExpression('desc', [ result ]);
        }
        return result;
      }));
    }

    // 18.2.5.2
    // construct does not need a project (select, ask and describe do)
    if (query.queryType === 'SELECT') {
      // Named nodes are only possible in a DESCRIBE so this cast is safe
      res = this.factory.createProject(res, <RDF.Variable[]> PV);
    }

    // 18.2.5.3
    if (select.distinct) {
      res = this.factory.createDistinct(res);
    }

    // 18.2.5.4
    if (select.reduced) {
      res = this.factory.createReduced(res);
    }

    // NEW: support for ask/construct/describe queries
    if (query.queryType === 'CONSTRUCT') {
      res = this.factory.createConstruct(res, (query.template ?? []).map(this.translateQuad));
    } else if (query.queryType === 'ASK') {
      res = this.factory.createAsk(res);
    } else if (query.queryType === 'DESCRIBE') {
      res = this.factory.createDescribe(res, PV);
    }

    // Slicing needs to happen after construct/describe
    // 18.2.5.5
    if (select.offset ?? select.limit) {
      res = this.factory.createSlice(res, select.offset ?? 0, select.limit);
    }

    if (select.from) {
      res = this.factory.createFrom(res, select.from.default, select.from.named);
    }

    return res;
  }

  // Rewrites some of the input sparql object to make use of aggregate variables
  private mapAggregate(thingy: mapAggregateType, aggregates: NodeJS.Dict<AggregateExpression>): any {
    if ('type' in thingy && thingy.type === 'aggregate') {
      let found = false;
      let v;
      for (const key of Object.keys(aggregates)) {
        if (equal(aggregates[key], thingy)) {
          v = this.factory.createTerm(key);
          found = true;
          break;
        }
      }
      if (!found) {
        v = this.generateFreshVar();
        aggregates[termToString(v)] = thingy;
      }
      return v;
    }

    // Non-aggregate expression
    if ('expression' in thingy && thingy.expression) {
      return { ...thingy, expression: this.mapAggregate(thingy.expression, aggregates) };
    }
    if ('args' in thingy && thingy.args) {
      return { ...thingy, args: thingy.args.map(subthingy => this.mapAggregate(<mapAggregateType>subthingy, aggregates)) };
    }

    // Normal variable/wildcard
    return thingy;
  }

  private translateBoundAggregate(thingy: AggregateExpression, v: RDF.Variable): Algebra.BoundAggregate {
    if (thingy.type !== 'aggregate' || !thingy.aggregation) {
      throw new Error(`Unexpected input: ${JSON.stringify(thingy)}`);
    }

    const A = <Algebra.BoundAggregate> this.translateExpression(thingy);
    A.variable = v;

    return A;
  }

  private translateUpdate(thingy: Update): Algebra.Operation {
    if (thingy.updates.length === 1) {
      return this.translateSingleUpdate(thingy.updates[0]);
    }
    return this.factory.createCompositeUpdate(thingy.updates.map(this.translateSingleUpdate));
  }

  private translateSingleUpdate(thingy: UpdateOperation): Algebra.Update {
    if ('type' in thingy) {
      if (thingy.type === 'load') {
        return this.translateUpdateGraphLoad(thingy);
      }
      if (thingy.type === 'clear' || thingy.type === 'create' || thingy.type === 'drop') {
        return this.translateUpdateGraph(thingy);
      }
      if (thingy.type === 'add' || thingy.type === 'copy' || thingy.type === 'move') {
        return this.translateUpdateGraphShortcut(thingy);
      }
    } else if (thingy.updateType === 'insertdelete' || thingy.updateType === 'deletewhere' ||
      thingy.updateType === 'delete' || thingy.updateType === 'insert') {
      return this.translateInsertDelete(<any> thingy);
    }

    throw new Error(`Unknown update type ${JSON.stringify(thingy)}`);
  }

  private translateInsertDelete(
    thingy: InsertDeleteOperation & {
      delete?: TempDelIns;
      insert?: TempDelIns;
      where?: Pattern[];
      graph?: RDF.NamedNode;
    },
  ): Algebra.Update {
    if (!useQuads) {
      throw new Error('INSERT/DELETE operations are only supported with quads option enabled');
    }

    let deleteTriples: Algebra.Pattern[] = [];
    let insertTriples: Algebra.Pattern[] = [];
    let where: Algebra.Operation;
    if (thingy.delete) {
      deleteTriples = Util.flatten(thingy.delete.map(input => this.translateUpdateTriplesBlock(input, thingy.graph)));
    }
    if (thingy.insert) {
      insertTriples = Util.flatten(thingy.insert.map(input => this.translateUpdateTriplesBlock(input, thingy.graph)));
    }
    if (thingy.where && thingy.where.length > 0) {
      where = this.translateGraphPattern({ type: 'group', patterns: thingy.where });
      // Wrong typings, see test "using" in Sparql.js
      const use: { default: RDF.NamedNode[]; named: RDF.NamedNode[] } | undefined = (<any> thingy).using;
      if (use) {
        where = this.factory.createFrom(where, use.default, use.named);
      } else if (thingy.graph) {
        // This is equivalent
        where = this.recurseGraph(where, thingy.graph);
      }
    } else if (thingy.updateType === 'deletewhere' && deleteTriples.length > 0) {
      where = this.factory.createBgp(deleteTriples);
    }

    return this.factory.createDeleteInsert(
      deleteTriples.length > 0 ? deleteTriples : undefined,
      insertTriples.length > 0 ? insertTriples : undefined,
      where!,
    );
  }

  // UPDATE parsing will always return quads and have no GRAPH elements
  private translateUpdateTriplesBlock(thingy: BgpPattern | GraphQuads, graph?: RDF.NamedNode): Algebra.Pattern[] {
    let currentGraph: RDF.NamedNode | RDF.Variable | undefined = graph;
    if (thingy.type === 'graph') {
      currentGraph = thingy.name;
    }
    let currentTriples = thingy.triples;
    if (currentGraph) {
      currentTriples = currentTriples.map(triple => Object.assign(triple, { graph: currentGraph }));
    }
    return currentTriples.map(translateQuad);
  }

  private translateUpdateGraph(thingy: CreateOperation | ClearDropOperation): Algebra.Update {
    let source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode;
    if (Util.isSimpleTerm(thingy.graph)) {
      source = <any> thingy.graph;
    } else {
      const graph: typeof thingy.graph & { all?: unknown; default?: unknown; named?: unknown } = thingy.graph;
      if (graph.all) {
        source = 'ALL';
      } else if (graph.default) {
        source = 'DEFAULT';
      } else if (graph.named) {
        source = 'NAMED';
      } else {
        source = thingy.graph.name!;
      }
    }

    switch (thingy.type) {
      case 'clear': return this.factory.createClear(source, thingy.silent);
      case 'create': return this.factory.createCreate(<RDF.NamedNode> source, thingy.silent);
      case 'drop': return this.factory.createDrop(source, thingy.silent);
    }
  }

  private translateUpdateGraphLoad(thingy: LoadOperation): Algebra.Load {
    return this.factory.createLoad(thingy.source, <RDF.NamedNode | undefined> thingy.destination, thingy.silent);
  }

  private translateUpdateGraphShortcut(thingy: CopyMoveAddOperation): Algebra.Update {
    const source: 'DEFAULT' | RDF.NamedNode = thingy.source.default ? 'DEFAULT' : <RDF.NamedNode> thingy.source.name;
    const destination: 'DEFAULT' | RDF.NamedNode = thingy.destination.default ?
      'DEFAULT' :
      <RDF.NamedNode> thingy.destination.name;
    switch (thingy.type) {
      case 'copy': return this.factory.createCopy(source, destination, thingy.silent);
      case 'move': return this.factory.createMove(source, destination, thingy.silent);
      case 'add': return this.factory.createAdd(source, destination, thingy.silent);
    }
  }

  private translateBlankNodesToVariables(res: Algebra.Operation): Algebra.Operation {
    const factory = this.factory;
    const blankToVariableMapping: Record<string, RDF.Variable> = {};
    const variablesRaw: Record<string, boolean> = [ ...this.variables ]
      .reduce((acc: Record<string, boolean>, variable: string) => {
        acc[variable] = true;
        return acc;
      }, {});
    return Util.mapOperation(res, {
      [Algebra.Types.DELETE_INSERT]: (op: Algebra.DeleteInsert) =>
        // Make sure blank nodes remain in the INSERT block, but do update the WHERE block
        ({
          result: factory.createDeleteInsert(
            op.delete,
            op.insert,
            op.where && this.translateBlankNodesToVariables(op.where),
          ),
          recurse: false,
        }),
      [Algebra.Types.PATH]: (op: Algebra.Path, factory: Factory) => ({
        result: factory.createPath(
          blankToVariable(op.subject),
          op.predicate,
          blankToVariable(op.object),
          blankToVariable(op.graph),
        ),
        recurse: false,
      }),
      [Algebra.Types.PATTERN]: (op: Algebra.Pattern, factory: Factory) => ({
        result: factory.createPattern(
          blankToVariable(op.subject),
          blankToVariable(op.predicate),
          blankToVariable(op.object),
          blankToVariable(op.graph),
        ),
        recurse: false,
      }),
      [Algebra.Types.CONSTRUCT]: (op: Algebra.Construct) =>
        // Blank nodes in CONSTRUCT templates must be maintained
        ({
          result: factory.createConstruct(this.translateBlankNodesToVariables(op.input), op.template),
          recurse: false,
        })
      ,
    });

    function blankToVariable(term: RDF.Term): RDF.Term {
      if (term.termType === 'BlankNode') {
        let variable = blankToVariableMapping[term.value];
        if (!variable) {
          variable = Util.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);
          variablesRaw[variable.value] = true;
          blankToVariableMapping[term.value] = variable;
        }
        return variable;
      }
      if (term.termType === 'Quad') {
        return factory.dataFactory.quad(
          blankToVariable(term.subject),
          blankToVariable(term.predicate),
          blankToVariable(term.object),
          blankToVariable(term.graph),
        );
      }
      return term;
    }
  }
}
