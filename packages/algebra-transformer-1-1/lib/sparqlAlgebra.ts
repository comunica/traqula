import type * as RDF from '@rdfjs/types';
import type { AlterNodeOutput, SubTyped } from '@traqula/core';
import { Transformer } from '@traqula/core';
import {
  DatasetClauses,

  Factory as AstFactory,
  GraphRef,
  GraphRefAll,
  GraphRefDefault,
  GraphRefNamed,
  GraphRefSpecific, Quads,
  UpdateOperationCopy,
  UpdateOperationDeleteData,
  UpdateOperationDeleteWhere,
  UpdateOperationInsertData,
  UpdateOperationModify,
  UpdateOperationMove,
} from '@traqula/rules-sparql-1-1';
import type {

  BasicGraphPattern,
  Expression,
  GraphQuads,
  Ordering,
  PathNegatedElt,
  PathPure,
  Pattern,
  PatternBgp,
  PatternGroup,
  Query,
  Sparql11Nodes,
  SparqlQuery,
  Term,
  TermVariable,
  TripleCollection,
  TripleNesting,
  Wildcard,
  TermBlank,
  TermLiteral,
  TermIri,
  PatternFilter,
  PatternValues,

  ExpressionAggregate,
  PatternBind,
  Update,
  UpdateOperation,
  UpdateOperationLoad,
  UpdateOperationCreate,
  type UpdateOperationClear,
  type UpdateOperationDrop,
} from '@traqula/rules-sparql-1-1';
import equal from 'fast-deep-equal/es6';
import { DataFactory } from 'rdf-data-factory';
import * as Algebra from './algebra';
import Factory from './factory';
import Util from './util';

const Parser = require('sparqljs').Parser;

const types = Algebra.Types;
const typeVals = Object.values(types);

type mapAggregateType = Wildcard | Expression | Ordering | PatternBind;
type TempDelIns = (PatternBgp | GraphQuads)[];

export type TransformedNamed<T extends object> = AlterNodeOutput<T, SubTyped<'term', 'namedNode'>, RDF.Term>;
type AstToRdfTerm<T extends Term> = T extends TermVariable ? RDF.Variable :
  T extends TermBlank ? RDF.BlankNode :
    T extends TermLiteral ? RDF.Literal :
      T extends TermIri ? RDF.NamedNode : never;
type TransformGraphRef<T extends GraphRef> = T extends GraphRefDefault ?  'DEFAULT' : T extends GraphRefNamed ? 'NAMED' :
  T extends GraphRefAll ? 'ALL' : T extends TermIri ? RDF.NamedNode : never;
export interface FlattenedTriple {
  subject: RDF.Term;
  predicate: RDF.Term | PathPure;
  object: RDF.Term;
}

/**
 * Translates the given SPARQL query to SPARQL Algebra.
 * @param query - Either a SPARQL string or an object generated by sparql.js
 * @param options - Optional options object. Current options:
 *    * @param options.dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.
 *    * @param options.quads: Boolean indicating whether triples should be converted to Quads
 *        (consumes GRAPH statements). Default false.
 *    * @param options.prefixes: Pre-defined prefixes for the given query. Default empty.
 *    * @param options.baseIRI: Base IRI that should be used for the query.
 *        Default undefined (throws error if required).
 * @returns {Operation}
 */
export default function translate(query: SparqlQuery, options: {
  dataFactory?: RDF.DataFactory;
  quads?: boolean;
  prefixes?: Record<string, string>;
  baseIRI?: string;
  blankToVariable?: boolean;
} = {}): Algebra.Operation {
  const queryTranslator = new QueryTranslator(new Factory(options.dataFactory));

  return queryTranslator.translateQuery(query, options.quads, options.blankToVariable);
}

class QueryTranslator {
  /**
   * This set is filled in during the inScopeVariables call
   */
  private variables = new Set<string>();
  private varCount = 0;
  private useQuads = false;
  private readonly transformer = new Transformer<Sparql11Nodes>();
  private readonly astFactory = new AstFactory();
  private readonly dataFactory = new DataFactory();

  public constructor(private readonly factory: Factory) {}

  public translateQuery(sparql: SparqlQuery, quads?: boolean, blankToVariable?: boolean): Algebra.Operation {
    this.variables = new Set();
    this.varCount = 0;
    this.useQuads = quads ?? false;

    let result: Algebra.Operation;

    // Find ALL variables here to fill `variables` array - needed to create fresh variables
    this.findAllVariables(sparql);

    if (this.astFactory.isQuery(sparql)) {
      // Group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE
      const group: PatternGroup = sparql.where ?? this.astFactory.patternGroup([], this.astFactory.sourceLocation());
      result = this.translateGraphPattern(group);
      // 18.2.4 Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions
      result = this.translateAggregates(sparql, result);
    } else if (sparql.type === 'update') {
      result = this.translateUpdate(sparql);
    }
    if (blankToVariable) {
      result = this.translateBlankNodesToVariables(result!);
    }

    return result!;
  }

  public isString(str: any): str is string {
    return typeof str === 'string';
  }

  private isTerm(term: any): term is RDF.Term {
    return Boolean(term?.termType);
  }

  // This is not completely correct but this way we also catch SPARQL.js triples
  private isTriple(triple: any): triple is RDF.Quad {
    return triple.subject && triple.predicate && triple.object;
  }

  private isVariable(term: any): term is RDF.Variable {
    return term?.termType === 'Variable';
  }

  // Will be used to make sure new variables don't overlap
  private findAllVariables(thingy: object): void {
    this.transformer.visitObjects(thingy, (current) => {
      if (this.astFactory.alwaysSparql11(current)) {
        if (this.astFactory.isTermVariable(current)) {
          this.variables.add(current.value);
        } else if (this.astFactory.isPatternValues(current)) {
          for (const key in current.values.at(0) ?? {}) {
            this.variables.add(key);
          }
        }
      }
    });
  }

  // 18.2.1
  private inScopeVariables(thingy: SparqlQuery | Pattern | PropertyPath | RDF.Term): Record<string, RDF.Variable> {
    const inScope: Record<string, RDF.Variable> = {};

    if (this.isTriple(thingy)) {
      // Note that this could both be an actual Quad or a SPARQL.js triple (without graph)
      const result = [
        this.inScopeVariables(thingy.subject),
        this.inScopeVariables(thingy.predicate),
        this.inScopeVariables(thingy.object),
        thingy.graph ? this.inScopeVariables(thingy.graph) : {},
      ];
      Object.assign(inScope, ...result);
    } else if (this.isTerm(thingy)) {
      if (this.isVariable(thingy)) {
        inScope[thingy.value] = thingy;
      }
    } else if (thingy.type === 'bgp') {
      // Slightly cheating but this is a subset of what we support so is fine
      const quads = <RDF.Quad[]> thingy.triples;
      Object.assign(inScope, ...quads.map(this.inScopeVariables));
    } else if (thingy.type === 'path') {
      // A path predicate should not have variables but just iterating so we could theoretically support this
      Object.assign(inScope, ...thingy.items.map(this.inScopeVariables));
    } else if (thingy.type === 'group' || thingy.type === 'union' || thingy.type === 'optional') {
      Object.assign(inScope, ...thingy.patterns.map(this.inScopeVariables));
    } else if (thingy.type === 'service' || thingy.type === 'graph') {
      Object.assign(inScope, this.inScopeVariables(thingy.name));
      Object.assign(inScope, ...thingy.patterns.map(this.inScopeVariables));
    } else if (thingy.type === 'bind') {
      Object.assign(inScope, this.inScopeVariables(thingy.variable));
    } else if (thingy.type === 'values') {
      if (thingy.values.length > 0) {
        const vars = Object.keys(thingy.values[0]).map(v => this.factory.createTerm(v));
        Object.assign(inScope, ...vars.map(this.inScopeVariables));
      }
    } else if (thingy.type === 'query' && (thingy.queryType === 'SELECT' || thingy.queryType === 'DESCRIBE')) {
      if (thingy.where && thingy.variables.some(Util.isWildcard)) {
        Object.assign(inScope, ...thingy.where.map(this.inScopeVariables));
      }
      for (const v of thingy.variables) {
        if (this.isVariable(v)) {
          Object.assign(inScope, this.inScopeVariables(v));
        } else if ((<VariableExpression> v).variable) {
          Object.assign(inScope, this.inScopeVariables((<VariableExpression> v).variable));
        }
      }
      if (thingy.queryType === 'SELECT') {
        if (thingy.group) {
          // Grouping can be a VariableExpression, typings are wrong
          for (const g of thingy.group) {
            if ((<VariableExpression> g).variable) {
              Object.assign(inScope, this.inScopeVariables((<VariableExpression> g).variable));
            }
          }
        }
        if (thingy.values) {
          const values: ValuesPattern = { type: 'values', values: thingy.values };
          Object.assign(inScope, this.inScopeVariables(values));
        }
      }
    }

    return inScope;
  }

  /**
   * 18.2.2.1: Expand Syntax Forms - partly done by sparql parser, partly here, and partly in BGP
   * https://www.w3.org/TR/sparql11-query/#sparqlExpandForms
   * https://www.w3.org/TR/sparql11-query/#QSynIRI
   */
  private expandNamedNodes<Node extends Sparql11Nodes>(node: Node): Node {
    const F = this.astFactory;
    return <Node> this.transformer.transformNodeSpecific(node, 'term', 'namedNode', (cur) => {
      if (F.isTermNamedPrefixed(cur)) {
        // TODO: relate yourself prefix
        return F.namedNode(cur.loc, cur.value);
      }
      // TODO: relate yourself to base
      return F.namedNode(cur.loc, cur.value);
    });
  }

  private translateGraphPattern(pattern: Pattern): Algebra.Operation {
    pattern = this.expandNamedNodes(pattern);

    if (this.astFactory.isPatternBgp(pattern)) {
      return this.translateBgp(pattern);
    }

    // 18.2.2.6: Translate Graph Patterns - GroupOrUnionGraphPattern
    if (this.astFactory.isPatternUnion(pattern)) {
      return this.factory.createUnion(
        pattern.patterns.map((group: PatternGroup) => this.translateGraphPattern(group)),
      );
    }

    // 18.2.2.6: Translate Graph Patterns - GraphGraphPattern
    if (this.astFactory.isPatternGraph(pattern)) {
      // Sparql.js combines the group graph pattern and the graph itself in the same object.
      // We split here so the group graph pattern can be interpreted correctly.
      const group = this.astFactory.patternGroup(pattern.patterns, pattern.loc);
      let result = this.translateGraphPattern(group);

      // Output depends on if we use quads or not
      if (this.useQuads) {
        result = this.recurseGraph(result, pattern.name);
      } else {
        result = this.factory.createGraph(result, this.translateTerm(pattern.name));
      }

      return result;
    }

    // 18.2.2.6: Translate Graph Patterns - InlineData
    if (this.astFactory.isPatternValues(pattern)) {
      return this.translateInlineData(pattern);
    }

    // 18.2.2.6: Translate Graph Patterns - SubSelect
    if (this.astFactory.isQuerySelect(pattern)) {
      return this.translateQuery(pattern, this.useQuads, false);
    }

    // 18.2.2.6: Translate Graph Patterns - GroupGraphPattern
    if (this.astFactory.isPatternGroup(pattern)) {
      // 18.2.2.2 - Collect FILTER Elements
      const filters: PatternFilter[] = [];
      const nonfilters: Pattern[] = [];
      for (const subPattern of pattern.patterns) {
        if (this.astFactory.isPatternFilter(subPattern)) {
          filters.push(subPattern);
        } else {
          nonfilters.push(subPattern);
        }
      }

      // 18.2.2.6 - GroupGraphPattern
      let result: Algebra.Operation = this.factory.createBgp([]);
      for (const pattern of nonfilters) {
        result = this.accumulateGroupGraphPattern(result, pattern);
      }

      // 18.2.2.7 - Filters of Group - translateExpression handles notExists negation.
      const expressions: Algebra.Expression[] = filters.map(filter => this.translateExpression(filter.expression));
      if (expressions.length > 0) {
        let conjunction = expressions[0];
        for (const expression of expressions.slice(1)) {
          conjunction = this.factory.createOperatorExpression('&&', [ conjunction, expression ]);
        }
        // One big filter applied on the group
        result = this.factory.createFilter(result, conjunction);
      }

      return result;
    }

    throw new Error(`Unexpected pattern: ${pattern.subType}`);
  }

  /**
   * Handles part of: 18.2.2.2 Collect FILTER Elements
   */
  private translateExpression(expr: Expression | Wildcard): Algebra.Expression {
    const F = this.astFactory;
    if (F.isTerm(expr)) {
      return this.factory.createTermExpression(this.translateTerm(expr));
    }

    if (F.isWildcard(expr)) {
      return this.factory.createWildcardExpression();
    }

    if (F.isExpressionAggregate(expr)) {
      return this.factory.createAggregateExpression(
        expr.aggregation,
        this.translateExpression(expr.expression[0]),
        expr.distinct,
        F.isExpressionAggregateSeparator(expr) ? expr.separator : undefined,
      );
    }

    if (F.isExpressionFunctionCall(expr)) {
      // Outdated typings
      return this.factory.createNamedExpression(
        this.translateTerm(expr.function),
        expr.args.map(subExpr => this.translateExpression(subExpr)),
      );
    }

    if (F.isExpressionOperator(expr)) {
      return this.factory.createOperatorExpression(
        expr.operator,
        expr.args.map(subExpr => this.translateExpression(subExpr)),
      );
    }

    if (F.isExpressionPatternOperation(expr)) {
      return this.factory.createExistenceExpression(
        expr.operator === 'notexists',
        this.translateGraphPattern(expr.args),
      );
    }

    throw new Error(`Unknown expression: ${JSON.stringify(expr)}`);
  }

  private translateTerm<T extends Term>(term: T): AstToRdfTerm<T> {
    const F = this.astFactory;
    const dataFact = this.dataFactory;
    if (F.isTermNamed(term)) {
      return <AstToRdfTerm<T>> dataFact.namedNode(term.value);
    }
    if (F.isTermBlank(term)) {
      return <AstToRdfTerm<T>> dataFact.blankNode(term.label);
    }
    if (F.isTermVariable(term)) {
      return <AstToRdfTerm<T>> dataFact.variable(term.value);
    }
    throw new Error(`Unexpected term: ${JSON.stringify(term)}`);
  }

  private translateTripleCollection(collection: TripleCollection, result: FlattenedTriple[]): void {
    this.translateBasicGraphPattern(collection.triples, result);
  }

  private translateTripleNesting(triple: TripleNesting, result: FlattenedTriple[]): void {
    const F = this.astFactory;
    let subject: RDF.Term;
    let predicate: RDF.Term | PathPure;
    let object: RDF.Term;
    if (F.isTripleCollection(triple.subject)) {
      this.translateTripleCollection(triple.subject, result);
      subject = this.translateTerm(triple.subject.identifier);
    } else {
      subject = this.translateTerm(triple.subject);
    }

    if (F.isPathPure(triple.predicate)) {
      predicate = triple.predicate;
    } else {
      predicate = this.translateTerm(triple.predicate);
    }

    if (F.isTripleCollection(triple.object)) {
      this.translateTripleCollection(triple.object, result);
      object = this.translateTerm(triple.object.identifier);
    } else {
      object = this.translateTerm(triple.object);
    }

    result.push({
      subject,
      predicate,
      object,
    });
  }

  private translateBasicGraphPattern(triples: BasicGraphPattern, result: FlattenedTriple[]): void {
    const F = this.astFactory;
    for (const triple of triples) {
      if (F.isTripleCollection(triple)) {
        this.translateBasicGraphPattern(triple.triples, result);
      } else {
        this.translateTripleNesting(triple, result);
      }
    }
  }

  /**
   * 18.2.2.1: Expand Syntax Forms: Flatten TripleCollection
   * 18.2.2.3: Translate Property Path Expressions
   * 18.2.2.4: Translate Property Path Patterns
   * 18.2.2.5: Translate Basic Graph Patterns
   * TODO: In the ast, a group with a single BGP in it is a single object. (TODO: not anymore)
   */
  private translateBgp(bgp: PatternBgp): Algebra.Operation {
    let patterns: Algebra.Pattern[] = [];
    const joins: Algebra.Operation[] = [];
    const flattenedTriples: FlattenedTriple[] = [];
    this.translateBasicGraphPattern(bgp.triples, flattenedTriples);
    for (const triple of flattenedTriples) {
      if (this.astFactory.isPathPure(triple.predicate)) {
        const smartType = <FlattenedTriple & { predicate: PathPure }> triple;
        // TranslatePath returns a mix of Quads and Paths
        const path = this.translatePath(smartType);
        for (const p of path) {
          if (p.type === types.PATH) {
            if (patterns.length > 0) {
              joins.push(this.factory.createBgp(patterns));
            }
            patterns = [];
            joins.push(p);
          } else {
            patterns.push(p);
          }
        }
      } else {
        patterns.push(this.translateQuad(triple));
      }
    }
    if (patterns.length > 0) {
      joins.push(this.factory.createBgp(patterns));
    }
    if (joins.length === 1) {
      return joins[0];
    }
    return this.factory.createJoin(joins);
  }

  /**
   * 18.2.2.3 Translate Property Path Expressions
   * 18.2.2.4 Translate Property Path Patterns
   */
  private translatePath(triple: FlattenedTriple & { predicate: PathPure }):
  (Algebra.Path | Algebra.Pattern)[] {
    const sub = triple.subject;
    const pred = this.translatePathPredicate(triple.predicate);
    const obj = triple.object;

    return this.simplifyPath(sub, pred, obj);
  }

  /**
   * 18.2.2.3 Translate Property Path Expressions
   */
  private translatePathPredicate(predicate: RDF.NamedNode | PathPure): Algebra.PropertyPathSymbol {
    // Iri -> link(iri)
    if (this.isTerm(predicate)) {
      return this.factory.createLink(predicate);
    }

    // ^path -> inv(path)
    if (predicate.subType === '^') {
      return this.factory.createInv(this.translatePathPredicate(<RDF.NamedNode | PathPure> predicate.items[0]));
    }

    if (predicate.subType === '!') {
      // Negation is either over a single predicate or a list of disjuncted properties - that can only have modifier '^'
      const normals: RDF.NamedNode[] = [];
      const inverted: RDF.NamedNode[] = [];
      // Either the item of this one is an `|`, `^` or `iri`
      const contained = predicate.items[0];
      let items: (RDF.NamedNode | PathNegatedElt)[];
      if (this.astFactory.isPathPure(contained) && contained.subType === '|') {
        items = <(RDF.NamedNode | PathNegatedElt)[]> contained.items;
      } else {
        items = [ <RDF.NamedNode | PathNegatedElt> contained ];
      }

      for (const item of items) {
        if (this.isTerm(item)) {
          normals.push(item);
        } else if (item.subType === '^') {
          inverted.push(<RDF.NamedNode> <unknown> item.items[0]);
        } else {
          throw new Error(`Unexpected item: ${JSON.stringify(item)}`);
        }
      }

      // NPS elements do not have the LINK function
      const normalElement = this.factory.createNps(normals);
      const invertedElement = this.factory.createInv(this.factory.createNps(inverted));

      // !(:iri1|...|:irin) -> NPS({:iri1 ... :irin})
      if (inverted.length === 0) {
        return normalElement;
      }
      // !(^:iri1|...|^:irin) -> inv(NPS({:iri1 ... :irin}))
      if (normals.length === 0) {
        return invertedElement;
      }
      // !(:iri1|...|:irii|^:irii+1|...|^:irim -> alt(NPS({:iri1 ...:irii}), inv(NPS({:irii+1, ..., :irim})) )
      return this.factory.createAlt([ normalElement, invertedElement ]);
    }

    // Path1 / path -> seq(path1, path2)
    if (predicate.subType === '/') {
      return this.factory.createSeq(predicate.items.map(item => this.translatePathPredicate(<PathPure> item)));
    }
    // Path1 | path2 -> alt(path1, path2)
    if (predicate.subType === '|') {
      return this.factory.createAlt(predicate.items.map(item => this.translatePathPredicate(<PathPure> item)));
    }
    // Path* -> ZeroOrMorePath(path)
    if (predicate.subType === '*') {
      return this.factory.createZeroOrMorePath(this.translatePathPredicate(<PathPure> predicate.items[0]));
    }
    // Path+ -> OneOrMorePath(path)
    if (predicate.subType === '+') {
      return this.factory.createOneOrMorePath(this.translatePathPredicate(<PathPure> predicate.items[0]));
    }
    // Path? -> ZeroOrOnePath(path)
    if (predicate.subType === '?') {
      return this.factory.createZeroOrOnePath(this.translatePathPredicate(<PathPure> predicate.items[0]));
    }

    throw new Error(`Unable to translate path expression ${JSON.stringify(predicate)}`);
  }

  /**
   * 18.2.2.4 Translate Property Path Patterns
   */
  private simplifyPath(
    subject: RDF.Term,
    predicate: Algebra.PropertyPathSymbol,
    object: RDF.Term,
  ): (Algebra.Pattern | Algebra.Path)[] {
    // X link(iri) Y -> X iri Y
    if (predicate.type === types.LINK) {
      return [ this.factory.createPattern(subject, predicate.iri, object) ];
    }

    // X inv(iri) Y -> Y iri X
    if (predicate.type === types.INV) {
      return this.simplifyPath(<RDF.Quad_Subject> object, predicate.path, subject);
    }

    // X seq(P, Q) Y -> X P ?V . ?V Q P
    if (predicate.type === types.SEQ) {
      let iter = subject;
      const result: (Algebra.Pattern | Algebra.Path)[] = [];
      for (const pathOfSeq of predicate.input.slice(0, -1)) {
        const joinVar = this.generateFreshVar();
        result.push(...this.simplifyPath(iter, pathOfSeq, joinVar));
        iter = joinVar;
      }
      result.push(...this.simplifyPath(iter, predicate.input.at(-1)!, object));
      return result;
    }

    // X P Y -> Path(X, P, Y)
    return [ this.factory.createPath(subject, predicate, object) ];
  }

  private generateFreshVar(): RDF.Variable {
    let newVar = `var${this.varCount++}`;
    while (this.variables.has(newVar)) {
      newVar = `var${this.varCount++}`;
    }
    this.variables.add(newVar);
    return this.dataFactory.variable(newVar);
  }

  private translateQuad(quad: FlattenedTriple): Algebra.Pattern {
    if (this.astFactory.isPathPure(quad.predicate)) {
      throw new Error('Trying to translate property path to quad.');
    }
    // Graphs are needed here
    // TODO: investigate if typings are wrong or if we internally add graphs to these
    return this.factory.createPattern(quad.subject, quad.predicate, quad.object, (<any> quad).graph);
  }

  /**
   * Translate terms to be of some graph (Jitse thinks?)
   */
  private recurseGraph(thingy: Algebra.Operation, graph: RDF.Term, replacement?: RDF.Variable): Algebra.Operation {
    if (thingy.type === types.GRAPH) {
      if (replacement) {
        // At this point we would lose track of the replacement which would result in incorrect results
        // This would indicate the library is not being used as intended though
        throw new Error('Recursing through nested GRAPH statements with a replacement is impossible.');
      }
      // In case there were nested GRAPH statements that were not recursed yet for some reason
      thingy = this.recurseGraph(thingy.input, thingy.name);
    } else if (thingy.type === types.SERVICE) {
      // Service blocks are not affected by enclosing GRAPH statements, so nothing is modified in this block.
      // See https://github.com/joachimvh/SPARQLAlgebra.js/pull/104#issuecomment-1838016303
    } else if (thingy.type === types.BGP) {
      thingy.patterns = thingy.patterns.map((quad) => {
        if (replacement) {
          if (quad.subject.equals(graph)) {
            quad.subject = replacement;
          }
          if (quad.predicate.equals(graph)) {
            quad.predicate = replacement;
          }
          if (quad.object.equals(graph)) {
            quad.object = replacement;
          }
        }
        if (quad.graph.termType === 'DefaultGraph') {
          quad.graph = graph;
        }
        return quad;
      });
    } else if (thingy.type === types.PATH) {
      if (replacement) {
        if (thingy.subject.equals(graph)) {
          thingy.subject = replacement;
        }
        if (thingy.object.equals(graph)) {
          thingy.object = replacement;
        }
      }
      if (thingy.graph.termType === 'DefaultGraph') {
        thingy.graph = graph;
      }
    } else if (thingy.type === types.PROJECT && !replacement) {
      // Need to replace variables in subqueries should the graph also be a variable of the same name
      // unless the subquery projects that variable
      if (!thingy.variables.some(v => v.equals(graph))) {
        replacement = this.generateFreshVar();
      }
      thingy.input = this.recurseGraph(thingy.input, graph, replacement);
    } else if (thingy.type === types.EXTEND && !replacement) {
      // This can happen if the query extends an expression to the name of the graph
      // since the extend happens here there should be no further occurrences of this name
      // if there are it's the same situation as above
      if (thingy.variable.equals(graph)) {
        replacement = this.generateFreshVar();
      }
      thingy.input = this.recurseGraph(thingy.input, graph, replacement);
    } else {
      for (const key of Object.keys(thingy)) {
        if (Array.isArray(thingy[key])) {
          thingy[key] = thingy[key].map((x: any) => this.recurseGraph(x, graph, replacement));
        } else if (this.typeVals.includes(thingy[key].type)) {
          // Can't do instanceof on an interface
          thingy[key] = this.recurseGraph(thingy[key], graph, replacement);
        } else if (replacement && this.isVariable(thingy[key]) && thingy[key].equals(graph)) {
          thingy[key] = replacement;
        }
      }
    }

    return thingy;
  }

  /**
   * 18.2.2.6 Translate Graph Patterns - GroupGraphPattern
   */
  private accumulateGroupGraphPattern(algebraOp: Algebra.Operation, pattern: Pattern): Algebra.Operation {
    const F = this.astFactory;
    if (F.isPatternOptional(pattern)) {
      // Optional input needs to be interpreted as a group
      const groupAsAlgebra = this.translateGraphPattern(F.patternGroup(pattern.patterns, pattern.loc));
      if (groupAsAlgebra.type === types.FILTER) {
        return this.factory.createLeftJoin(algebraOp, groupAsAlgebra.input, groupAsAlgebra.expression);
      }
      return this.factory.createLeftJoin(algebraOp, groupAsAlgebra);
    }

    if (F.isPatternMinus(pattern)) {
      // Minus input needs to be interpreted as a group
      const groupAsAlgebra = this.translateGraphPattern(F.patternGroup(pattern.patterns, pattern.loc));
      return this.factory.createMinus(algebraOp, groupAsAlgebra);
    }

    if (F.isPatternBind(pattern)) {
      return this.factory.createExtend(
        algebraOp,
        this.translateTerm(pattern.variable),
        this.translateExpression(pattern.expression),
      );
    }

    if (F.isPatternService(pattern)) {
      // Transform to group so child-nodes get parsed correctly
      const group = F.patternGroup(pattern.patterns, pattern.loc);
      const A = this.factory.createService(
        this.translateGraphPattern(group),
        this.translateTerm(pattern.name),
        pattern.silent,
      );
      return this.simplifiedJoin(algebraOp, A);
    }

    const A = this.translateGraphPattern(pattern);
    return this.simplifiedJoin(algebraOp, A);
  }

  private simplifiedJoin(G: Algebra.Operation, A: Algebra.Operation): Algebra.Operation {
    // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.
    if (G.type === types.BGP && A.type === types.BGP) {
      G = this.factory.createBgp([ ...G.patterns, ...A.patterns ]);
    } else if (G.type === types.BGP && G.patterns.length === 0) {
      // 18.2.2.8 (simplification)
      G = A;
    } else if (A.type === types.BGP && A.patterns.length === 0) {
      // Do nothing
    } else {
      G = this.factory.createJoin([ G, A ]);
    }
    return G;
  }

  private translateInlineData(values: PatternValues): Algebra.Values {
    const variables = values.values.length === 0 ?
        [] :
      Object.keys(values.values[0]).map(key => this.dataFactory.variable(key));
    const bindings = values.values.map((binding) => {
      const map: Record<string, RDF.NamedNode | RDF.Literal> = {};
      for (const [ key, value ] of Object.entries(binding)) {
        if (value !== undefined) {
          map[key] = this.translateTerm(value);
        }
      }
      return map;
    });
    return this.factory.createValues(variables, bindings);
  }

  // --------------------------------------- AGGREGATES
  /**
   * 18.2.4
   */
  private translateAggregates(query: Query, res: Algebra.Operation): Algebra.Operation {
    const F = this.astFactory;
    const bindPatterns: PatternBind[] = [];

    const varAggrMap: Record<string, ExpressionAggregate> = {};
    if (F.isQuerySelect(query)) {
      for (const val of query.variables) {
        this.mapAggregate(val, varAggrMap);
      }
    }
    if (query.solutionModifiers.having) {
      for (const val of query.solutionModifiers.having.having) {
        this.mapAggregate(val, varAggrMap);
      }
    }
    if (query.solutionModifiers.order) {
      for (const val of query.solutionModifiers.order.orderDefs) {
        this.mapAggregate(val, varAggrMap);
      }
    }

    // Step: GROUP BY - If we found an aggregate, in group by or implicitly, do Group function.
    // 18.2.4.1 Grouping and Aggregation
    if (query.solutionModifiers.group ?? Object.keys(varAggrMap).length > 0) {
      const aggregates = Object.keys(varAggrMap).map(var_ =>
        this.translateBoundAggregate(varAggrMap[var_], this.dataFactory.variable(var_)));
      const vars: RDF.Variable[] = [];
      if (query.solutionModifiers.group) {
        for (const expression of query.solutionModifiers.group.groupings) {
          // https://www.w3.org/TR/sparql11-query/#rGroupCondition
          if (F.isTerm(expression)) {
            // This will always be a var, otherwise sparql would be invalid
            vars.push(this.translateTerm(<TermVariable> expression));
          } else if ('variable' in expression) {
            const var_ = this.translateTerm(expression.variable);
            res = this.factory.createExtend(res, var_, this.translateExpression(expression.value));
          } else {
            const var_ = this.generateFreshVar();
            res = this.factory.createExtend(res, var_, this.translateExpression(expression));
            vars.push(var_);
          }
        }
      }
      res = this.factory.createGroup(res, vars, aggregates);
    }

    // 18.2.4.2
    if (query.solutionModifiers.having) {
      for (const filter of query.solutionModifiers.having.having) {
        res = this.factory.createFilter(res, this.translateExpression(filter));
      }
    }

    // 18.2.4.3
    if (query.values) {
      res = this.factory.createJoin([ res, this.translateInlineData(query.values) ]);
    }

    // 18.2.4.4
    let PatternValues: (RDF.Variable | RDF.NamedNode)[] = [];

    if (F.isQuerySelect(query) || F.isQueryDescribe(query)) {
      // Sort variables for consistent output
      if (query.variables.some(wild => F.isWildcard(wild))) {
        PatternValues = Object.values(this.inScopeVariables(query))
          .sort((left, right) => left.value.localeCompare(right.value));
      } else {
        // Wildcard has been filtered out above
        for (const var_ of <Exclude<typeof query.variables, [Wildcard]>> query.variables) {
          // Can have non-variables with DESCRIBE
          if (F.isTerm(var_)) {
            PatternValues.push(this.translateTerm(var_));
          } else {
            // ... AS ?x
            PatternValues.push(this.translateTerm(var_.variable));
            bindPatterns.push(var_);
          }
        }
      }
    }

    // TODO: Jena simplifies by having a list of extends
    for (const bind of bindPatterns) {
      res = this.factory.createExtend(
        res,
        this.translateTerm(bind.variable),
        this.translateExpression(bind.expression),
      );
    }

    // 18.2.5
    // not using toList and toMultiset

    // 18.2.5.1
    if (query.solutionModifiers.order) {
      res = this.factory.createOrderBy(res, query.solutionModifiers.order.orderDefs.map((expr) => {
        let result = this.translateExpression(expr.expression);
        if (expr.descending) {
          result = this.factory.createOperatorExpression('desc', [ result ]);
        }
        return result;
      }));
    }

    // 18.2.5.2
    // construct does not need a project (select, ask and describe do)
    if (F.isQuerySelect(query)) {
      // Named nodes are only possible in a DESCRIBE so this cast is safe
      res = this.factory.createProject(res, <RDF.Variable[]> PatternValues);
    }

    // 18.2.5.3
    if ((<{ distinct?: unknown }>query).distinct) {
      res = this.factory.createDistinct(res);
    }

    // 18.2.5.4
    if ((<{ reduced?: unknown }>query).reduced) {
      res = this.factory.createReduced(res);
    }

    if (F.isQueryConstruct(query)) {
      const triples: FlattenedTriple[] = [];
      this.translateBasicGraphPattern(query.template.triples, triples);
      res = this.factory.createConstruct(res, triples.map(quad => this.translateQuad(quad)));
    } else if (F.isQueryAsk(query)) {
      res = this.factory.createAsk(res);
    } else if (F.isQueryDescribe(query)) {
      res = this.factory.createDescribe(res, PatternValues);
    }

    // Slicing needs to happen after construct/describe
    // 18.2.5.5
    const limitOffset = query.solutionModifiers.limitOffset;
    if (limitOffset?.limit ?? limitOffset?.offset) {
      res = this.factory.createSlice(res, limitOffset.offset ?? 0, limitOffset.limit);
    }

    if (query.datasets.clauses.length > 0) {
      const clauses = this.translateDatasetClause(query.datasets);
      res = this.factory.createFrom(res, clauses.default, clauses.named);
    }

    return res;
  }

  // Rewrites some of the input sparql object to make use of aggregate variables
  private mapAggregate(thingy: mapAggregateType, aggregates: Record<string, ExpressionAggregate>): void {
    const F = this.astFactory;

    if (F.isExpressionAggregate(thingy)) {
      let val: RDF.Variable | undefined;
      for (const [ key, aggregate ] of Object.entries(aggregates)) {
        if (equal(aggregate, thingy)) {
          val = this.dataFactory.variable(key);
          break;
        }
      }
      if (val !== undefined) {
        return;
      }
      const freshVar = this.generateFreshVar();
      aggregates[freshVar.value] = thingy;
      return;
    }

    if (F.isExpressionPure(thingy) && !F.isExpressionPatternOperation(thingy)) {
      for (const expr of thingy.args) {
        this.mapAggregate(expr, aggregates);
      }
      return;
    }

    // Non-aggregate expression
    if ('expression' in thingy && thingy.expression) {
      this.mapAggregate(thingy.expression, aggregates);
    }
  }

  private translateBoundAggregate(thingy: ExpressionAggregate, variable: RDF.Variable): Algebra.BoundAggregate {
    const A = <Algebra.AggregateExpression> this.translateExpression(thingy);
    return { ...A, variable };
  }

  private translateUpdate(thingy: Update): Algebra.Operation {
    if (thingy.updates.length === 1) {
      return this.translateSingleUpdate(thingy.updates[0]);
    }
    return this.factory.createCompositeUpdate(thingy.updates.map(this.translateSingleUpdate));
  }

  private translateSingleUpdate(op: UpdateOperation): Algebra.Update {
    const F = this.astFactory;
    if (F.isUpdateOperationLoad(op)) {
      return this.translateUpdateGraphLoad(op);
    }
    if (F.isUpdateOperationClear(op)) {
      return this.factory.createClear(this.translateGraphRef(op.destination), op.silent);
    }
    if (F.isUpdateOperationCreate(op)) {
      return this.factory.createCreate(this.translateGraphRef(op.destination), op.silent);
    }
    if (F.isUpdateOperationDrop(op)) {
      return this.factory.createDrop(this.translateGraphRef(op.destination), op.silent);
    }
    if (F.isUpdateOperationAdd(op)) {
      return this.factory.createAdd(this.translateGraphRef(op.source), this.translateGraphRef(op.destination), op.silent);
    }
    if (F.isUpdateOperationCopy(op)) {
      return this.factory.createCopy(this.translateGraphRef(op.source), this.translateGraphRef(op.destination), op.silent);

    } if( F.isUpdateOperationMove(op)) {
      return this.factory.createMove(this.translateGraphRef(op.source), this.translateGraphRef(op.destination), op.silent);
    }
    if (F.isUpdateOperationInsertData(op) || F.isUpdateOperationDeleteData(op) || F.isUpdateOperationDeleteWhere(op) ||
      F.isUpdateOperationModify(op)) {
      return this.translateInsertDelete(op);
    }

    throw new Error(`Unknown update type ${JSON.stringify(op)}`);
  }

  private translateInsertDelete(
    op: UpdateOperationInsertData | UpdateOperationDeleteData | UpdateOperationDeleteWhere | UpdateOperationModify
  ): Algebra.Update {
    if (!this.useQuads) {
      throw new Error('INSERT/DELETE operations are only supported with quads option enabled');
    }

    const F = this.astFactory;
    const deleteTriples: Algebra.Pattern[] = [];
    const insertTriples: Algebra.Pattern[] = [];
    let where: Algebra.Operation | undefined;
    if (F.isUpdateOperationDeleteData(op) || F.isUpdateOperationDeleteWhere(op)) {
      deleteTriples.push(...op.data.flatMap(quad => this.translateUpdateTriplesBlock(quad)))
      if (F.isUpdateOperationDeleteWhere(op)) {
        where = this.factory.createBgp(deleteTriples);
      }
    } else if (F.isUpdateOperationInsertData(op)) {
      insertTriples.push(...op.data.flatMap(quad => this.translateUpdateTriplesBlock(quad)))
    } else {
      deleteTriples.push(...op.delete.flatMap(quad => this.translateUpdateTriplesBlock(quad)))
      insertTriples.push(...op.insert.flatMap(quad => this.translateUpdateTriplesBlock(quad)))
      if (op.where.length > 0) {
        where = this.translateGraphPattern(F.patternGroup(op.where, F.sourceLocation(...op.where)));
        const use: { default: RDF.NamedNode[]; named: RDF.NamedNode[] } = this.translateDatasetClause(op.from);
        if (use.default.length > 0 || use.named.length > 0) {
          where = this.factory.createFrom(where, use.default, use.named);
        } else if (F.isUpdateOperationModify(op) && op.graph) {
          // This is equivalent
          where = this.recurseGraph(where, this.translateTerm(op.graph));
        }
      }
    }

    return this.factory.createDeleteInsert(
      deleteTriples.length > 0 ? deleteTriples : undefined,
      insertTriples.length > 0 ? insertTriples : undefined,
      where,
    );
  }

  private translateDatasetClause(dataset: DatasetClauses): { default: RDF.NamedNode[]; named: RDF.NamedNode[] } {
    return {
      default: dataset.clauses.filter(x => x.clauseType === 'default').map(x => this.translateTerm(x.value)),
      named: dataset.clauses.filter(x => x.clauseType === 'named').map(x => this.translateTerm(x.value)),
    }
  }

  // UPDATE parsing will always return quads and have no GRAPH elements
  private translateUpdateTriplesBlock(thingy: BgpPattern | GraphQuads, graph?: RDF.NamedNode): Algebra.Pattern[] {
    let currentGraph: RDF.NamedNode | RDF.Variable | undefined = graph;
    if (thingy.type === 'graph') {
      currentGraph = thingy.name;
    }
    let currentTriples = thingy.triples;
    if (currentGraph) {
      currentTriples = currentTriples.map(triple => Object.assign(triple, { graph: currentGraph }));
    }
    return currentTriples.map(translateQuad);
  }

  private translateGraphRef<T extends GraphRef>(graph: T): TransformGraphRef<T> {
    const F = this.astFactory;
    if (F.isGraphRefAll(graph)) {
      return <TransformGraphRef<T>> 'ALL';
    } else if (F.isGraphRefDefault(graph)) {
      return <TransformGraphRef<T>> 'DEFAULT';
    } else if (F.isGraphRefNamed(graph)) {
      return <TransformGraphRef<T>> 'NAMED';
    } else {
      return <TransformGraphRef<T>> this.translateTerm(graph.graph);
    }
  }
  private translateUpdateGraph(op: UpdateOperationClear | UpdateOperationDrop | UpdateOperationCreate):
  Algebra.Update {
    const F = this.astFactory;
    let source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode;
    const dest = op.destination;
    if (F.isGraphRefAll(dest)) {
      source = 'ALL';
    } else if (F.isGraphRefDefault(dest)) {
      source = 'DEFAULT';
    } else if (F.isGraphRefNamed(dest)) {
      source = 'NAMED';
    } else {
      source = this.translateTerm(dest.graph);
    }

    switch (op.) {
      case 'clear': return this.factory.createClear(source, op.silent);
      case 'create': return this.factory.createCreate(<RDF.NamedNode> source, op.silent);
      case 'drop': return this.factory.createDrop(source, op.silent);
    }
  }

  private translateUpdateGraphLoad(op: UpdateOperationLoad): Algebra.Load {
    return this.factory.createLoad(
      this.translateTerm(op.source),
      op.destination ? this.translateTerm(op.destination.graph) : undefined,
      op.silent,
    );
  }

  private translateBlankNodesToVariables(res: Algebra.Operation): Algebra.Operation {
    const factory = this.factory;
    const blankToVariableMapping: Record<string, RDF.Variable> = {};
    const variablesRaw: Record<string, boolean> = [ ...this.variables ]
      .reduce((acc: Record<string, boolean>, variable: string) => {
        acc[variable] = true;
        return acc;
      }, {});
    return Util.mapOperation(res, {
      [Algebra.Types.DELETE_INSERT]: (op: Algebra.DeleteInsert) =>
        // Make sure blank nodes remain in the INSERT block, but do update the WHERE block
        ({
          result: factory.createDeleteInsert(
            op.delete,
            op.insert,
            op.where && this.translateBlankNodesToVariables(op.where),
          ),
          recurse: false,
        }),
      [Algebra.Types.PATH]: (op: Algebra.Path, factory: Factory) => ({
        result: factory.createPath(
          blankToVariable(op.subject),
          op.predicate,
          blankToVariable(op.object),
          blankToVariable(op.graph),
        ),
        recurse: false,
      }),
      [Algebra.Types.PATTERN]: (op: Algebra.Pattern, factory: Factory) => ({
        result: factory.createPattern(
          blankToVariable(op.subject),
          blankToVariable(op.predicate),
          blankToVariable(op.object),
          blankToVariable(op.graph),
        ),
        recurse: false,
      }),
      [Algebra.Types.CONSTRUCT]: (op: Algebra.Construct) =>
        // Blank nodes in CONSTRUCT templates must be maintained
        ({
          result: factory.createConstruct(this.translateBlankNodesToVariables(op.input), op.template),
          recurse: false,
        })
      ,
    });

    function blankToVariable(term: RDF.Term): RDF.Term {
      if (term.termType === 'BlankNode') {
        let variable = blankToVariableMapping[term.value];
        if (!variable) {
          variable = Util.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);
          variablesRaw[variable.value] = true;
          blankToVariableMapping[term.value] = variable;
        }
        return variable;
      }
      if (term.termType === 'Quad') {
        return factory.dataFactory.quad(
          blankToVariable(term.subject),
          blankToVariable(term.predicate),
          blankToVariable(term.object),
          blankToVariable(term.graph),
        );
      }
      return term;
    }
  }
}
