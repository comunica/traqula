import { IndirBuilder } from '@traqula/core';
import type { PatternGroup, SparqlQuery } from '@traqula/rules-sparql-1-1';
import type { Algebra } from '../index';
import { mapAggregate, translateAggregates, translateBoundAggregate } from './aggregate';
import { createAlgebraContext } from './core';
import type { AlgebraIndir, ContextConfigs } from './core';
import {
  findAllVariables,
  generateFreshVar,
  registerContextDefinitions,
  translateBlankNodesToVariables,
  translateDatasetClause,
  translateInlineData,
  translateNamed,
  translateTerm,
} from './general';
import { simplifyPath, translatePath, translatePathPredicate } from './path';
import {
  accumulateGroupGraphPattern,
  simplifiedJoin,
  translateBgp,
  translateExpression,
  translateGraphPattern,
} from './patterns';
import {
  recurseGraph,
  translateBasicGraphPattern,
  translateQuad,
  translateTripleCollection,
  translateTripleNesting,
} from './tripleAndQuad';
import {
  translateGraphRef,
  translateGraphRefDefSpec,
  translateGraphRefSpecific,
  translateInsertDelete,
  translateSingleUpdate,
  translateUpdate,
  translateUpdateGraphLoad,
  translateUpdateTriplesBlock,
} from './updates';

export const translateQuery:
AlgebraIndir<'translateQuery', Algebra.Operation, [SparqlQuery, boolean | undefined, boolean | undefined]> = {
  name: 'translateQuery',
  fun: ({ SUBRULE }) => (c, sparql, quads, blankToVariable) => {
    const F = c.astFactory;
    c.variables = new Set();
    c.varCount = 0;
    c.useQuads = quads ?? false;

    let result: Algebra.Operation;

    // Find ALL variables here to fill `variables` array - needed to create fresh variables
    SUBRULE(findAllVariables, sparql);

    if (F.isQuery(sparql)) {
      SUBRULE(registerContextDefinitions, sparql.context);
      // Group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE
      const group: PatternGroup = sparql.where ?? F.patternGroup([], F.gen());
      result = SUBRULE(translateGraphPattern, group);
      // 18.2.4 Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions
      result = SUBRULE(translateAggregates, sparql, result);
    } else {
      result = SUBRULE(translateUpdate, sparql);
    }
    if (blankToVariable) {
      result = SUBRULE(translateBlankNodesToVariables, result);
    }

    return result!;
  },
};

export const sparqlAlgebraTransformerBuilder = IndirBuilder
  .create(<const> [
    // Aggregate
    translateAggregates,
    mapAggregate,
    translateBoundAggregate,
  ])
  .addMany(
    // General
    translateNamed,
    translateTerm,
    registerContextDefinitions,
    translateInlineData,
    translateDatasetClause,
    translateBlankNodesToVariables,
    findAllVariables,
    generateFreshVar,
    // Path
    translatePath,
    translatePathPredicate,
    simplifyPath,
    // Patterns
    translateExpression,
    translateGraphPattern,
    translateBgp,
    accumulateGroupGraphPattern,
    simplifiedJoin,
    // TripleAndQuad
    translateTripleCollection,
    translateBasicGraphPattern,
    translateTripleNesting,
    recurseGraph,
    translateQuad,
    // Updates
    translateUpdate,
    translateSingleUpdate,
    translateInsertDelete,
    translateUpdateTriplesBlock,
    translateGraphRefSpecific,
    translateGraphRefDefSpec,
    translateGraphRef,
    translateUpdateGraphLoad,
    // ToAlgebra
    translateQuery,
  );

/**
 * Translates the given SPARQL query to SPARQL Algebra.
 * @param query - sparql AST generated by Traqula
 * @param options - Optional options object. Current options:
 * @param options.dataFactory - The Datafactory used to generate terms. Default @rdfjs/data-model.
 * @param options.quads - Boolean indicating whether triples should be converted to Quads
 *        (consumes GRAPH statements). Default false.
 * @param options.prefixes - Pre-defined prefixes for the given query. Default empty.
 * @param options.baseIRI - Base IRI that should be used for the query.
 *        Default undefined (throws error if required).
 * @param options.blankToVariable - translate all blank nodes into variables
 * @returns Operation
 */
export default function translate(query: SparqlQuery, options: ContextConfigs = {}): Algebra.Operation {
  const c = createAlgebraContext(options);
  const transformer = sparqlAlgebraTransformerBuilder.build();
  return transformer.translateQuery(c, query, options.quads, options.blankToVariable);
}
